<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ‹¾è‚†é›€ï¼šArcade Plus (å«æ§“ç‰Œç‰ˆ)</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; background: #051a10; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; position: fixed; width: 100%; font-family: sans-serif; }
        #canvasContainer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { background: radial-gradient(circle, #1a5e3a 0%, #0b2e1d 100%); display: block; touch-action: none; max-width: 100%; max-height: 100%; object-fit: contain; }
    </style>
</head>
<body>
<div id="canvasContainer">
    <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GW = 720, GH = 1280;

let gameStatus = 'START_SCREEN'; 
let totalScore = 0, movesLeft = 15, timeLeft = 60;
let hand = [], pool = [], deck = [], flowersWon = [], gangsWon = []; 
let swapActionCount = 0, gameCount = 0; 
let selectedHandIndex = -1, selectedPoolIndex = -1, lastTimestamp = 0;
let isTenpai = false; 
let richiPad = []; 

// --- æ–°å¢æ§“ç‰Œç›¸é—œè®Šæ•¸ ---
let gangCandidates = []; // å­˜å„²å¯æ§“çš„ç‰Œå‹ Key
let isGangSelecting = false; // æ˜¯å¦è™•æ–¼é¸æ“‡æ§“ç‰Œæ¨¡å¼
// ---------------------

let winInfo = { names: [], totalTai: 0, scale: 0, thisWinTotal: 0 };
let winPending = false; 
let glowValue = 0;

const WIND_ORDER = ['ğŸ€€', 'ğŸ€', 'ğŸ€‚', 'ğŸ€ƒ'];
let roundWind = 'ğŸ€€', seatWind = 'ğŸ€€';

const TILES_DATA = {
    'MAN':  ['ğŸ€‡','ğŸ€ˆ','ğŸ€‰','ğŸ€Š','ğŸ€‹','ğŸ€Œ','ğŸ€','ğŸ€','ğŸ€'],
    'TONG': ['ğŸ€™','ğŸ€š','ğŸ€›','ğŸ€œ','ğŸ€','ğŸ€','ğŸ€Ÿ','ğŸ€ ','ğŸ€¡'],
    'TIAO': ['ğŸ€','ğŸ€‘','ğŸ€’','ğŸ€“','ğŸ€”','ğŸ€•','ğŸ€–','ğŸ€—','ğŸ€˜'],
    'WIND': ['ğŸ€€','ğŸ€','ğŸ€‚','ğŸ€ƒ'], 
    'DRAGON':['ğŸ€„','ğŸ€…','ğŸ€†'],    
    'FLOWER':['ğŸ€¢','ğŸ€£','ğŸ€¤','ğŸ€¥','ğŸ€¦','ğŸ€§','ğŸ€¨','ğŸ€©'] 
};

const delay = ms => new Promise(res => setTimeout(res, ms));

function playTone(freq, dur, vol = 0.1) {
    if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = window.audioCtx.createOscillator();
    const g = window.audioCtx.createGain();
    osc.connect(g); g.connect(window.audioCtx.destination);
    osc.start(); osc.stop(window.audioCtx.currentTime + dur);
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    canvas.addEventListener('pointerdown', handleInput);
    lastTimestamp = Date.now();
    requestAnimationFrame(loop);
}

function resize() {
    const scale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
    canvas.width = GW * scale; canvas.height = GH * scale;
    ctx.scale(scale, scale);
}

function resetAndStart(isFullReset) {
    if(isFullReset) { totalScore = 0; gameCount = 0; } else { gameCount++; }
    movesLeft = 15; timeLeft = 60; winInfo = { totalTai: 0 }; 
    seatWind = WIND_ORDER[gameCount % 4];
    roundWind = WIND_ORDER[Math.floor((gameCount / 4) % 4)];
    swapActionCount = 0; flowersWon = []; gangsWon = [];
    selectedHandIndex = -1; selectedPoolIndex = -1;
    winPending = false; isTenpai = false; richiPad = [];
    gangCandidates = []; isGangSelecting = false; // é‡ç½®æ§“ç‰Œç‹€æ…‹
    startOpeningSequence();
}

async function startOpeningSequence() {
    gameStatus = 'DEALING';
    let validDeal = false;
    
    while(!validDeal) {
        deck = createDeck();
        let testHand = deck.slice(-14);
        let check = calculateTotalTai(testHand, [], []);
        if(!check || (check.reduce((a,b)=>a+b.tai,0) <= 4)) validDeal = true;
    }

    hand = []; pool = [];
    const grabbingSteps = [4, 3, 3, 3, 1]; 
    for(let stepCount of grabbingSteps) {
        for(let i = 0; i < stepCount; i++) {
            let t = deck.pop(); t.x = 800; t.y = 1080; 
            hand.push(t);
            playTone(500 + (hand.length * 30), 0.08, 0.05);
            await delay(60); 
        }
    }
    await handleFlowers();
    sortHand(); 
    fillFullPool();
    checkGangStatus(); // æª¢æŸ¥èµ·æ‰‹æ˜¯å¦æœ‰æš—æ§“
    checkTenpaiStatus();
    gameStatus = 'PLAYING';
}

async function handleFlowers() {
    let hasFlower = true;
    while(hasFlower) {
        hasFlower = false;
        for(let i = 0; i < hand.length; i++) {
            if(hand[i].type === 'FLOWER') {
                playTone(1100, 0.1, 0.1);
                flowersWon.push(hand[i]);
                if(deck.length === 0) deck = createDeck();
                let newTile = deck.pop();
                newTile.x = hand[i].x; newTile.y = hand[i].y;
                hand[i] = newTile;
                hasFlower = true; await delay(200); break;
            }
        }
    }
}

function fillFullPool() {
    pool = [];
    let tempDeck = deck.filter(t => t.type !== 'FLOWER');
    for(let i=0; i<15; i++) {
        let t = tempDeck.pop();
        t.targetX = 110 + (i % 5) * 125; t.targetY = 480 + Math.floor(i / 5) * 145;
        t.x = GW/2; t.y = GH/2;
        pool.push(t);
    }
}

// --- æ§“ç‰Œé‚è¼¯ ---
function checkGangStatus() {
    const counts = {};
    hand.forEach(t => {
        const key = t.type + (t.val || t.txt);
        counts[key] = (counts[key] || 0) + 1;
    });
    gangCandidates = Object.keys(counts).filter(k => counts[k] === 4);
    if (gangCandidates.length === 0) isGangSelecting = false;
}

async function performGang(targetKey) {
    if (gameStatus !== 'PLAYING') return;

    // 1. ç´€éŒ„è¦æ§“çš„ç‰Œ
    const exampleTile = hand.find(t => (t.type + (t.val || t.txt)) === targetKey);
    
    // 2. ç§»é™¤æ‰‹ç‰Œä¸­çš„ 4 å¼µ
    hand = hand.filter(t => (t.type + (t.val || t.txt)) !== targetKey);
    
    // 3. åŠ å…¥æ§“ç‰Œå€
    gangsWon.push({ isAnGang: true, tile: exampleTile, txt: exampleTile.txt });
    
    // 4. å¶ºä¸Šé–‹èŠ±
    if(deck.length === 0) deck = createDeck();
    let newTile = deck.pop();
    newTile.x = GW / 2; newTile.y = GH + 100;
    hand.push(newTile);
    
    // 5. æ•ˆæœèˆ‡é‡ç½®
    playTone(300, 0.1); 
    setTimeout(() => playTone(800, 0.1), 150);
    
    isGangSelecting = false;
    selectedHandIndex = -1;
    
    sortHand(); 
    checkGangStatus(); 
    
    // æ§“å®Œå¾Œæª¢æŸ¥æ˜¯å¦èƒ¡ç‰Œ
    let results = calculateTotalTai(hand, flowersWon, gangsWon);
    if (results) {
        await delay(300);
        winPending = true; playTone(987, 0.3); triggerWin(results);
    } else {
        checkTenpaiStatus();
    }
}

function handleGangClick() {
    if (gangCandidates.length === 0) return;
    if (gangCandidates.length === 1) {
        performGang(gangCandidates[0]);
    } else {
        isGangSelecting = !isGangSelecting; 
        playTone(600, 0.05);
    }
}
// ----------------

async function performSwap(hIdx, pIdx) {
    if (gameStatus !== 'PLAYING' || winPending) return;
    
    const poolTile = { ...pool[pIdx] };
    let tempHand = [...hand]; tempHand[hIdx] = poolTile; 
    let results = calculateTotalTai(tempHand, flowersWon, gangsWon);
    
    if (results) {
        hand[hIdx] = poolTile; pool.splice(pIdx, 1);
        selectedHandIndex = -1; selectedPoolIndex = -1;
        sortHand(); await delay(200);
        winPending = true; playTone(987, 0.3); triggerWin(results);
    } else {
        if (!isTenpai) movesLeft--; 
        hand[hIdx] = poolTile;

        if(deck.length === 0) deck = createDeck();
        let newDeckTile = deck.pop();
        newDeckTile.x = GW / 2; newDeckTile.y = GH + 100; 
        newDeckTile.targetX = 110 + (pIdx % 5) * 125;
        newDeckTile.targetY = 480 + Math.floor(pIdx / 5) * 145;

        pool[pIdx] = newDeckTile;
        
        playTone(300, 0.05); 
        setTimeout(() => playTone(600, 0.05), 100); 
        
        selectedHandIndex = -1; selectedPoolIndex = -1;
        sortHand();
        checkGangStatus(); // æ›ç‰Œå¾Œæª¢æŸ¥æ˜¯å¦å‡ºç¾æ§“
        checkTenpaiStatus(); 
        if (movesLeft <= 0 && !isTenpai) gameStatus = 'FAIL';
    }
}

function checkTenpaiStatus() {
    let canRadar = false; 
    richiPad = new Array(hand.length).fill(false);
    for(let i=0; i<hand.length; i++) {
        if(checkSpecificRichi(i)) { canRadar = true; richiPad[i] = true; }
    }
    isTenpai = canRadar;
}

function checkSpecificRichi(hIdx) {
    const allU = [];
    ['MAN','TONG','TIAO'].forEach(type => { for(let i=1;i<=9;i++) allU.push({type, val:i, txt:TILES_DATA[type][i-1]}); });
    ['WIND','DRAGON'].forEach(type => { TILES_DATA[type].forEach(txt => allU.push({type, txt, val:null})); });
    for (let testTile of allU) {
        let tempHand = JSON.parse(JSON.stringify(hand)); tempHand[hIdx] = testTile;
        if (calculateTotalTai(tempHand, flowersWon, gangsWon)) return true;
    }
    return false;
}

function calculateTotalTai(h, flowers, gangs) {
    if (h.length !== (14 - gangs.length * 3)) return null;
    let taiList = [{ name: "åº•å°", tai: 2 }];
    const counts = {}; h.forEach(t => { const k = t.type + (t.val || t.txt); counts[k] = (counts[k] || 0) + 1; });
    const seatIdx = WIND_ORDER.indexOf(seatWind);
    flowers.forEach(f => {
        let idx = TILES_DATA['FLOWER'].indexOf(f.txt);
        if (idx === seatIdx || idx === seatIdx + 4) taiList.push({ name: `æ­£èŠ±`, tai: 1 });
    });
    gangs.forEach(g => taiList.push({ name: g.isAnGang?"æš—æ§“":"æ˜æ§“", tai: g.isAnGang?2:1 }));

    let best = null;
    for (let key in counts) { 
        if (counts[key] >= 2) {
            let tc = {...counts}; tc[key] -= 2; let m = [];
            if (findMianzi(tc, m)) { best = { jiang: key, mianzi: m }; break; }
        }
    }
    if (!best && gangs.length === 0) {
        let pairs = 0; for (let k in counts) if(counts[k]>=2) pairs += Math.floor(counts[k]/2);
        if (pairs === 7) return [{ name: "ä¸ƒå°å­", tai: 4 }, ...taiList];
    }
    if (!best) return null;

    let allTiles = [...h]; gangs.forEach(g => allTiles.push(g.tile));
    const suitC = new Set(allTiles.filter(t => ['MAN','TONG','TIAO'].includes(t.type)).map(t => t.type)).size;
    const hasWord = allTiles.some(t => ['WIND','DRAGON'].includes(t.type));
    if ((best.mianzi.filter(x => x.type === 'ke').length + gangs.length) === 4) taiList.push({ name: "å°å°èƒ¡", tai: 4 });
    if (suitC === 1 && !hasWord) taiList.push({ name: "æ¸…ä¸€è‰²", tai: 8 });
    else if (suitC === 1 && hasWord) taiList.push({ name: "æ··ä¸€è‰²", tai: 4 });
    return taiList;
}

function findMianzi(counts, structures) {
    let keys = Object.keys(counts).filter(k => counts[k] > 0).sort();
    if (keys.length === 0) return true;
    let first = keys[0];
    if (counts[first] >= 3) {
        counts[first] -= 3; structures.push({ type: 'ke' });
        if (findMianzi(counts, structures)) return true;
        structures.pop(); counts[first] += 3;
    }
    if (first.match(/MAN|TONG|TIAO/)) {
        let type = first.match(/MAN|TONG|TIAO/)[0], val = parseInt(first.replace(type, ''));
        let k2 = type + (val+1), k3 = type + (val+2);
        if (val <= 7 && counts[k2] > 0 && counts[k3] > 0) {
            counts[first]--; counts[k2]--; counts[k3]--; structures.push({ type: 'shun' });
            if (findMianzi(counts, structures)) return true;
            structures.pop(); counts[first]++; counts[k2]++; counts[k3]++;
        }
    }
    return false;
}

function draw() {
    ctx.clearRect(0, 0, GW, GH);
    ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.fillRect(0, 0, GW, 220);
    ctx.font = "bold 36px Arial"; ctx.textAlign = "center"; ctx.fillStyle = "#fff";
    ctx.fillText(`ç¬¬ ${gameCount + 1} å±€ | ${roundWind}åœˆ ${seatWind}é–€`, 360, 60);
    
    if (isTenpai) {
        ctx.fillStyle = "#0f0"; ctx.fillText(`è½ç‰Œä¸­: FREE MOVES`, 180, 130);
    } else {
        ctx.fillStyle = movesLeft <= 3 ? "#f44" : "#0fc"; ctx.fillText(`æ­¥æ•¸: ${movesLeft}`, 180, 130);
    }

    ctx.fillStyle = "#fc0"; ctx.fillText(`æ™‚é–“: ${Math.ceil(timeLeft)}s`, 540, 130);
    ctx.fillText(`ç¸½åˆ†: ${totalScore.toLocaleString()}`, 360, 190);
    
    flowersWon.forEach((f, i) => drawTile(60 + i*55, 280, f.txt, '#f57c00', 50, 70, false, 28));
    
    // ç¹ªè£½æ§“ç‰Œ (æ”¾åœ¨èŠ±ç‰Œæ—é‚Šæˆ–ä¸‹é¢)
    gangsWon.forEach((g, i) => {
         // ç¨å¾®éŒ¯é–‹ä½ç½®é¡¯ç¤º
         drawTile(GW - 80 - i*60, 280, g.txt, '#8e24aa', 55, 75, false, 30, true);
    });
    
    // ç¹ªè£½ç‰Œæ± 
    pool.forEach((p, i) => {
        drawTile(p.x, p.y, p.txt, getCol(p.type), 110, 150, i === selectedPoolIndex, 65);
    });
    
    ctx.fillStyle = "rgba(0,0,0,0.75)"; ctx.fillRect(0, 950, GW, 330);
    hand.forEach((t, i) => {
        let isFocus = i === selectedHandIndex;
        let showGlow = isTenpai && richiPad[i];
        
        // æ§“ç‰Œé¸æ“‡æ¨¡å¼ä¸‹çš„é«˜äº®
        if (isGangSelecting) {
            let key = t.type + (t.val || t.txt);
            if (gangCandidates.includes(key)) showGlow = true;
        }

        drawTile(t.x, t.y - (isFocus?45:0), t.txt, getCol(t.type), 92, 132, isFocus, null, showGlow);
    });

    // --- ç¹ªè£½æ§“ç‰ŒæŒ‰éˆ• ---
    if (gangCandidates.length > 0 && gameStatus === 'PLAYING' && !winPending) {
        let btnX = 580, btnY = 880, btnW = 120, btnH = 60;
        
        ctx.save();
        ctx.fillStyle = isGangSelecting ? "#f57f17" : "#ffca28"; 
        ctx.shadowBlur = 10; ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.fill();
        
        ctx.fillStyle = "#3e2723";
        ctx.font = "bold 32px Arial";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(isGangSelecting ? "é¸ç‰Œ" : "æ§“ !", btnX + btnW/2, btnY + btnH/2);
        ctx.restore();
    }
    // -----------------

    if (winPending) { ctx.fillStyle = "#fc0"; ctx.font = "bold 120px Arial"; ctx.fillText("æ¦® å’Œ !", 360, 640); }
    if (gameStatus === 'WIN_ANIM') drawWinOverlay();
    if (gameStatus === 'START_SCREEN') drawOverlay("æ‹¾è‚†é›€ï¼šArcade Plus", "é–‹å§‹æŒ‘æˆ°", "#fc0");
    if (gameStatus === 'FAIL') drawOverlay("æŒ‘æˆ°å¤±æ•—", "é‡æ–°é–‹å§‹", "#f44");
}

function triggerWin(results) {
    const sumTai = results.reduce((a, b) => a + b.tai, 0);
    const earned = (sumTai + Math.floor(timeLeft) + movesLeft) * 100;
    totalScore += earned; 
    winInfo = { names: results.map(r => `${r.name} ${r.tai}å°`), totalTai: sumTai, scale: 0, thisWinTotal: earned };
    gameStatus = 'WIN_ANIM'; playTone(880, 0.2);
}

function handleInput(e) {
    const rect = canvas.getBoundingClientRect();
    const scale = canvas.width / GW;
    const mx = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / scale;
    const my = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) / scale;
    
    if (gameStatus === 'START_SCREEN' || gameStatus === 'FAIL') return resetAndStart(true);
    if (gameStatus === 'WIN_ANIM' && winInfo.scale >= 1) return resetAndStart(false);
    if (gameStatus !== 'PLAYING' || winPending) return;

    // --- æª¢æ¸¬æ§“ç‰ŒæŒ‰éˆ• ---
    if (gangCandidates.length > 0) {
        let btnX = 580, btnY = 880, btnW = 120, btnH = 60;
        if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {
            handleGangClick();
            return;
        }
    }

    let clickedHandIndex = -1;
    hand.forEach((t, i) => { 
        if (Math.abs(mx - t.x) < 45 && Math.abs(my - t.y) < 65) clickedHandIndex = i;
    });

    if (clickedHandIndex !== -1) {
        // A. æ§“ç‰Œé¸æ“‡æ¨¡å¼
        if (isGangSelecting) {
            let t = hand[clickedHandIndex];
            let key = t.type + (t.val || t.txt);
            if (gangCandidates.includes(key)) {
                performGang(key); 
            } else {
                isGangSelecting = false; 
                playTone(200, 0.1); 
            }
            return; 
        }

        // B. æ­£å¸¸æ›ç‰Œæ¨¡å¼
        if (selectedPoolIndex !== -1) performSwap(clickedHandIndex, selectedPoolIndex); 
        else { selectedHandIndex = (selectedHandIndex===clickedHandIndex)?-1:clickedHandIndex; playTone(659,0.05); }
        return;
    }

    // ç‰Œæ± æ“ä½œ (è‹¥åœ¨é¸æ§“å‰‡ç¦ç”¨)
    if (!isGangSelecting) {
        pool.forEach((p, i) => { 
            if (Math.abs(mx - p.x) < 55 && Math.abs(my - p.y) < 75) {
                if (selectedHandIndex !== -1) performSwap(selectedHandIndex, i); 
                else { selectedPoolIndex = (selectedPoolIndex===i)?-1:i; playTone(523,0.05); }
            }
        });
    }
}

function update() {
    const now = Date.now(), dt = (now - lastTimestamp) / 1000; lastTimestamp = now;
    glowValue = (Math.sin(now / 150) + 1) / 2; 

    // æŒçºŒæª¢æŸ¥æ§“ç‰Œç‹€æ…‹
    if (gameStatus === 'PLAYING') checkGangStatus();

    if (gameStatus === 'PLAYING' && !winPending) {
        timeLeft -= dt; if (timeLeft <= 0) gameStatus = 'FAIL';
    }
    pool.forEach(p => { p.x += (p.targetX - p.x) * 0.15; p.y += (p.targetY - p.y) * 0.15; });
    hand.forEach((t, i) => { 
        let tx = 85 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145;
        if(!isNaN(t.x)) t.x += (tx - t.x) * 0.18; else t.x = tx;
        if(!isNaN(t.y)) t.y += (ty - t.y) * 0.18; else t.y = ty;
    });
}

function createDeck() {
    let d = [];
    ['MAN', 'TONG', 'TIAO'].forEach(type => { for (let i = 1; i <= 9; i++) for (let n = 0; n < 4; n++) d.push({ type, val: i, txt: TILES_DATA[type][i-1] }); });
    ['WIND', 'DRAGON'].forEach(type => TILES_DATA[type].forEach(txt => { for (let n = 0; n < 4; n++) d.push({ type, txt: txt, val: null }); }));
    TILES_DATA['FLOWER'].forEach(txt => d.push({ type: 'FLOWER', txt, val: null }));
    return d.sort(() => Math.random() - 0.5);
}

function sortHand() {
    const order = {'MAN':0, 'TONG':1, 'TIAO':2, 'WIND':3, 'DRAGON':4, 'FLOWER':5};
    hand.sort((a,b) => order[a.type] - order[b.type] || (a.val || a.txt).toString().localeCompare((b.val || b.txt).toString()));
}
function getCol(t) { return t==='MAN'?'#d32f2f':t==='TONG'?'#1976d2':t==='TIAO'?'#2e7d32':'#4a148c'; }
function drawTile(x, y, txt, color, w, h, isS, fs, isG = false) {
    ctx.save(); ctx.translate(x, y);
    if (isG) { ctx.shadowBlur = 15; ctx.shadowColor = "#0f0"; ctx.strokeStyle = "#0f0"; ctx.lineWidth = 4; ctx.strokeRect(-w/2, -h/2, w, h); }
    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 8); ctx.fill();
    ctx.strokeStyle = isS ? "#fc0" : "#bbb"; ctx.lineWidth = isS?4:2; ctx.stroke();
    ctx.fillStyle = color; ctx.font = `bold ${fs || w*0.7}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle"; 
    ctx.fillText(txt||'?', 0, 0); ctx.restore();
}
function drawWinOverlay() {
    ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
    ctx.save(); ctx.translate(360, 640); ctx.scale(winInfo.scale, winInfo.scale);
    ctx.fillStyle = "#fc0"; ctx.font = "bold 80px Arial"; ctx.textAlign="center";
    ctx.fillText(`${winInfo.totalTai} å°!`, 0, -200);
    ctx.font = "32px Arial"; ctx.fillStyle = "#fff";
    winInfo.names.forEach((n, i) => ctx.fillText(n, 0, -100 + i * 40));
    ctx.font = "40px Arial"; ctx.fillStyle = "#0f0";
    ctx.fillText(`å¾—åˆ†ï¼š+${winInfo.thisWinTotal.toLocaleString()}`, 0, 150);
    ctx.fillStyle = "#aaa"; ctx.font = "24px Arial"; ctx.fillText("é»æ“Šç¹¼çºŒä¸‹ä¸€å±€", 0, 250); ctx.restore();
    if(winInfo.scale < 1) winInfo.scale += 0.05;
}
function drawOverlay(t, b, c) {
    ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0, 0, GW, GH);
    ctx.fillStyle = "#fff"; ctx.font = "bold 80px Arial"; ctx.textAlign = "center"; ctx.fillText(t, 360, 500);
    ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(200, 600, 320, 120, 20); ctx.fill();
    ctx.fillStyle = "#000"; ctx.font = "bold 50px Arial"; ctx.fillText(b, 360, 675);
}
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
</script>
</body>
</html>