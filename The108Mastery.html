<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pixel JD - ÊãæËÇÜÈõÄ</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; background: #051a10; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; position: fixed; width: 100%; font-family: sans-serif; }
        #canvasContainer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { background: radial-gradient(circle, #1a5e3a 0%, #0b2e1d 100%); display: block; touch-action: none; max-width: 100%; max-height: 100%; object-fit: contain; }
    </style>
</head>
<body>
<div id="canvasContainer"><canvas id="gameCanvas"></canvas></div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GW = 720, GH = 1280;

    const WINDS = ['üÄÄ', 'üÄÅ', 'üÄÇ', 'üÄÉ']; 
    const TILES_DATA = {
        'MAN':    ['üÄá','üÄà','üÄâ','üÄä','üÄã','üÄå','üÄç','üÄé','üÄè'],
        'TONG':   ['üÄô','üÄö','üÄõ','üÄú','üÄù','üÄû','üÄü','üÄ†','üÄ°'],
        'TIAO':   ['üÄê','üÄë','üÄí','üÄì','üÄî','üÄï','üÄñ','üÄó','üÄò'],
        'WIND':   WINDS, 
        'DRAGON': ['üÄÑ','üÄÖ','üÄÜ']
    };

    let audioCtx = null;
    let gameStatus = 'MENU', totalScore = 0, movesLeft = 12, timeLeft = 60, initialTime = 60;
    let gameCount = 0, winStreak = 0, lastTickTime = 0, lastGainedScore = 0;
    let roundWindIdx = 0, seatWindIdx = 0;
    let hand = [], pool = [], deck = [];
    let selectedHandIndex = -1, selectedPoolIndex = -1;
    let lastTimestamp = 0, swapCount = 0;
    let winInfo = { names: [], totalFan: 0, scale: 0, isDraw: false, details: [] };

    // Áé©ÂÆ∂ËàáÊéíË°åÊ¶úË≥áÊñô
    let playerName = localStorage.getItem('pixel_jd_player_name') || "";
    let leaderBoard = JSON.parse(localStorage.getItem('pixel_jd_mahjong_rank')) || [];

    function saveScore(score, rounds) {
        // Â¶ÇÊûúÈÇÑÊ≤íÊúâÂêçÂ≠óÔºåË¶ÅÊ±ÇËº∏ÂÖ•
        if (!playerName) {
            let input = prompt("ÊÅ≠ÂñúÂÆåÊàêÊåëÊà∞ÔºÅË´ãËº∏ÂÖ•‰Ω†ÁöÑÂ§ßÂêçÔºö", "Èõû‰∏Å");
            playerName = input || "ÁÑ°ÂêçÊ∞è";
            localStorage.setItem('pixel_jd_player_name', playerName);
        }
        
        leaderBoard.push({ name: playerName, score, rounds });
        leaderBoard.sort((a, b) => b.score - a.score);
        leaderBoard = leaderBoard.slice(0, 5);
        localStorage.setItem('pixel_jd_mahjong_rank', JSON.stringify(leaderBoard));
    }

    function unlockAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playTone(freq, dur, vol = 0.3) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(vol, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + dur);
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('pointerdown', handleInput);
        lastTimestamp = Date.now();
        requestAnimationFrame(loop);
    }

    function resize() {
        const scale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
        canvas.width = GW * scale; canvas.height = GH * scale;
        ctx.scale(scale, scale);
    }

    async function resetAndStart(isFullReset) {
        unlockAudio();
        hand = []; pool = []; deck = [];
        if(isFullReset) { 
            totalScore = 0; movesLeft = 12; gameCount = 0; winStreak = 0;
            roundWindIdx = 0; seatWindIdx = 0;
        } else {
            gameCount++;
            seatWindIdx = gameCount % 4;
            roundWindIdx = Math.floor(gameCount / 4) % 4;
        }
        
        initialTime = (gameCount < 5) ? 60 : (gameCount < 15 ? 60 - (Math.floor(gameCount / 5) * 5) : Math.max(30, 50 - (Math.floor(gameCount / 10) * 5)));
        timeLeft = initialTime; lastTickTime = initialTime; 
        selectedHandIndex = -1; selectedPoolIndex = -1; swapCount = 0;
        gameStatus = 'DEALING';
        
        let fullDeck = createDeck();
        let suitTiles = fullDeck.filter(t => ['MAN', 'TONG', 'TIAO'].includes(t.type));
        let wordTiles = fullDeck.filter(t => ['WIND', 'DRAGON'].includes(t.type));
        let wordCountForHand = Math.floor(Math.random() * 4) + 2; 
        
        let tempHand = [];
        for(let i = 0; i < wordCountForHand; i++) tempHand.push(wordTiles.pop());
        while(tempHand.length < 14) tempHand.push(suitTiles.pop());
        deck = [...suitTiles, ...wordTiles].sort(() => Math.random() - 0.5);
        
        for(let i = 0; i < 14; i++) {
            let t = tempHand[i]; t.x = GW + 100; t.y = 1080 + Math.floor(i / 7) * 145; hand.push(t);
            if (i < 13) { playTone(500 + (i * 30), 0.08, 0.2); await new Promise(r => setTimeout(r, 100)); }
            else { playTone(800, 0.15, 0.4); }
        }
        setTimeout(() => { sortHand(); fillPool(); gameStatus = 'PLAYING'; }, 500);
    }

    function createDeck() {
        let d = [];
        ['MAN', 'TONG', 'TIAO'].forEach(type => {
            for (let i = 1; i <= 9; i++) for (let n = 0; n < 4; n++) d.push({ type, val: i, txt: TILES_DATA[type][i-1] });
        });
        ['WIND', 'DRAGON'].forEach(type => TILES_DATA[type].forEach(txt => {
            for (let n = 0; n < 4; n++) d.push({ type, txt, val: null });
        }));
        return d.sort(() => Math.random() - 0.5);
    }

    function fillPool() {
        if (deck.length === 0) return; 
        pool = [];
        while(pool.length < 9 && deck.length > 0) {
            let t = deck.pop(); t.x = GW/2; t.y = GH/2; 
            let i = pool.length;
            t.targetX = 230 + (i % 3) * 130; t.targetY = 480 + Math.floor(i / 3) * 145;
            pool.push(t);
        }
        if (deck.length === 0) checkFinalPossibility();
    }

    function checkFinalPossibility() {
        if (deck.length > 0) return;
        let canWin = false;
        for (let pTile of pool) {
            for (let i = 0; i < hand.length; i++) {
                let tempHand = JSON.parse(JSON.stringify(hand));
                tempHand[i] = pTile;
                if (calculateTotalFan(tempHand)) { canWin = true; break; }
            }
            if (canWin) break;
        }
        if (!canWin) {
            gameStatus = 'WAITING_DRAW';
            setTimeout(() => { triggerDrawGame("ÁâåÊ±†ÁÑ°Ëß£ÔºåËá™ÂãïÊµÅÂ±Ä"); }, 2000);
        }
    }

    function calculateTotalFan(h) {
        if (h.length !== 14) return null;
        let fanList = [];
        const counts = {}; 
        h.forEach(t => { const k = t.type + (t.val || t.txt); counts[k] = (counts[k] || 0) + 1; });
        if (checkThirteenOrphans(counts)) return [{ name: "ÂçÅ‰∏âÈ∫º", fan: 13 }];
        if (!h.some(t => ['MAN','TONG','TIAO'].includes(t.type))) return [{ name: "Â≠ó‰∏ÄËâ≤", fan: 13 }];
        let best = null;
        for (let key in counts) {
            if (counts[key] >= 2) {
                let tc = {...counts}; tc[key] -= 2;
                let m = []; if (findMianzi(tc, m)) { best = { jiang: key, mianzi: m }; break; }
            }
        }
        if (!best) return null;
        const kezi = best.mianzi.filter(x => x.type === 'ke');
        if (checkChuuren(h)) return [{ name: "‰πùËìÆÂØ∂Ááà", fan: 13 }];
        const windsCount = kezi.filter(x => x.tile.startsWith('WIND')).length;
        if (windsCount === 4) fanList.push({ name: "Â§ßÂõõÂñú", fan: 13 });
        else if (windsCount === 3 && best.jiang.startsWith('WIND')) fanList.push({ name: "Â∞èÂõõÂñú", fan: 8 });
        const isAll19 = h.every(t => (t.val === 1 || t.val === 9) || ['WIND','DRAGON'].includes(t.type));
        if (isAll19 && kezi.length === 4) {
            if (h.every(t => (t.val === 1 || t.val === 9))) fanList.push({ name: "Ê∏ÖÈ∫º‰πù", fan: 10 });
            else fanList.push({ name: "Ê∑∑È∫º‰πù", fan: 5 });
        }
        const dragonsCount = kezi.filter(x => x.tile.startsWith('DRAGON')).length;
        if (dragonsCount === 3) fanList.push({ name: "Â§ß‰∏âÂÖÉ", fan: 8 });
        else if (dragonsCount === 2 && best.jiang.startsWith('DRAGON')) fanList.push({ name: "Â∞è‰∏âÂÖÉ", fan: 5 });
        if (kezi.length === 4 && fanList.length === 0) fanList.push({ name: "Â∞çÂ∞çËÉ°", fan: 3 });
        const pureStatus = checkPureSuit(h);
        if (pureStatus === 'PURE') fanList.push({ name: "Ê∏Ö‰∏ÄËâ≤", fan: 7 });
        else if (pureStatus === 'MIXED' && !fanList.some(f => f.fan >= 5)) fanList.push({ name: "Ê∑∑‰∏ÄËâ≤", fan: 3 });
        kezi.forEach(k => {
            if (k.tile === 'WIND' + WINDS[roundWindIdx]) fanList.push({ name: "ÂúàÈ¢®Âàª", fan: 1 });
            if (k.tile === 'WIND' + WINDS[seatWindIdx]) fanList.push({ name: "ÈñÄÈ¢®Âàª", fan: 1 });
            const val = parseInt(k.tile.replace(/[A-Z]/g, ''));
            if (val === 1 || val === 9) fanList.push({ name: "È∫º‰πùÂàª", fan: 1 });
        });
        if (fanList.length === 0) fanList.push({ name: "ÈõûËÉ°", fan: 1 });
        return fanList;
    }

    function findMianzi(counts, m) {
        let keys = Object.keys(counts).filter(k => counts[k] > 0).sort();
        if (keys.length === 0) return true;
        let f = keys[0];
        if (counts[f] >= 3) { counts[f] -= 3; m.push({ type: 'ke', tile: f }); if (findMianzi(counts, m)) return true; m.pop(); counts[f] += 3; }
        if (f.match(/MAN|TONG|TIAO/)) {
            let type = f.match(/MAN|TONG|TIAO/)[0], val = parseInt(f.replace(type, ''));
            let k2 = type + (val+1), k3 = type + (val+2);
            if (val <= 7 && counts[k2] > 0 && counts[k3] > 0) { counts[f]--; counts[k2]--; counts[k3]--; m.push({ type: 'shun', tile: f }); if (findMianzi(counts, m)) return true; m.pop(); counts[f]++; counts[k2]++; counts[k3]++; }
        }
        return false;
    }

    function checkThirteenOrphans(counts) { const orphans = ['MAN1','MAN9','TONG1','TONG9','TIAO1','TIAO9','WINDüÄÄ','WINDüÄÅ','WINDüÄÇ','WINDüÄÉ','DRAGONüÄÑ','DRAGONüÄÖ','DRAGONüÄÜ']; return orphans.every(o => counts[o] >= 1) && Object.keys(counts).length === 13; }
    function checkChuuren(h) { const suits = new Set(h.map(t => t.type)); if (suits.size !== 1 || h.some(t => ['WIND','DRAGON'].includes(t.type))) return false; const vals = h.map(t => t.val).sort((a,b)=>a-b); const target = [1,1,1,2,3,4,5,6,7,8,9,9,9]; for(let v of target) { let idx = vals.indexOf(v); if(idx === -1) return false; vals.splice(idx, 1); } return true; }
    function checkPureSuit(h) { const suits = new Set(h.filter(t => ['MAN','TONG','TIAO'].includes(t.type)).map(t => t.type)); const hasWord = h.some(t => ['WIND','DRAGON'].includes(t.type)); if (suits.size === 1 && !hasWord) return 'PURE'; if (suits.size === 1 && hasWord) return 'MIXED'; return 'NONE'; }

    function draw() {
        ctx.clearRect(0, 0, GW, GH);
        if (gameStatus === 'MENU') drawMenu();
        else if (gameStatus === 'RULES') drawRules();
        else if (gameStatus === 'RANK') drawRank();
        else {
            ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0, 0, GW, 280);
            ctx.fillStyle = "#fff"; ctx.font = "bold 42px Arial"; ctx.textAlign = "center";
            ctx.fillText(`ÊãæËÇÜÈõÄÔºöÁ´∂ÊäÄÁµÇÊ•µÁâà`, 360, 60);
            ctx.fillStyle = "#fc0"; ctx.font = "bold 36px Arial"; ctx.fillText(`Á∏ΩÁ©çÂàÜ: ${totalScore.toLocaleString()}`, 360, 110);
            ctx.font = "bold 28px Arial"; ctx.fillStyle = "#aaa";
            ctx.fillText(`${WINDS[roundWindIdx]}È¢®Âúà / ÈñÄÈ¢®Ôºö${WINDS[seatWindIdx]}`, 360, 155);
            ctx.font = "bold 32px Arial";
            ctx.fillStyle = movesLeft <= 3 ? "#f44" : "#0fc"; ctx.fillText(`ÁîüÂëΩ: ${movesLeft}`, 180, 210);
            ctx.fillStyle = (timeLeft <= 10) ? "#f44" : "#fc0"; ctx.fillText(`ÈôêÊôÇ: ${Math.ceil(timeLeft)}s`, 540, 210);

            pool.forEach((p, i) => drawTile(p.x, p.y, p.txt, getCol(p.type), 115, 160, i === selectedPoolIndex));
            if (gameStatus === 'PLAYING' || gameStatus === 'WAITING_DRAW' || gameStatus === 'DEALING') {
                ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.beginPath(); ctx.roundRect(140, 370, 180, 40, 10); ctx.fill();
                ctx.fillStyle = "#fff"; ctx.font = "bold 24px Arial"; ctx.textAlign = "center"; ctx.fillText(`ÁâåÂ∫´Ââ©È§ò: ${deck.length}`, 230, 398);
            }
            if (gameStatus === 'PLAYING') {
                ctx.fillStyle = (deck.length > 0) ? "#e64a19" : "#333";
                ctx.beginPath(); ctx.roundRect(GW/2 - 150, 880, 300, 80, 15); ctx.fill();
                ctx.fillStyle = "#fff"; ctx.font = "bold 32px Arial"; ctx.textAlign = "center"; ctx.fillText("Êõ¥ÊèõÁâåÊ±†", GW/2, 932);
            }
            ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0, 970, GW, 310);
            hand.forEach((t, i) => drawTile(t.x, t.y - (i === selectedHandIndex ? 40 : 0), t.txt, getCol(t.type), 88, 125, i === selectedHandIndex));
            if (gameStatus === 'WIN_ANIM') drawResultOverlay();
            if (gameStatus === 'FAIL') drawOverlay("ÁîüÂëΩËÄóÁõ°", "ÂõûÂà∞È¶ñÈ†Å", "#f44");
        }
    }

    function drawMenu() {
        ctx.fillStyle = "#fff"; ctx.font = "bold 110px Arial"; ctx.textAlign = "center";
        ctx.fillText("ÊãæËÇÜÈõÄ", 360, 320);
        ctx.font = "36px Arial"; ctx.fillStyle = "#aaa";
        ctx.fillText("Pixel JD Ê¶ÆË≠ΩÂá∫ÂìÅ", 360, 400);

        if(playerName) {
            ctx.fillStyle = "#0fc"; ctx.font = "bold 32px Arial";
            ctx.fillText(`ÊåëÊà∞ËÄÖ: ${playerName}`, 360, 480);
        }

        if(leaderBoard.length > 0) {
            ctx.fillStyle = "#fc0"; ctx.font = "bold 42px Arial";
            ctx.fillText(`ÊúÄÈ´òÂàÜ: ${leaderBoard[0].score.toLocaleString()}`, 360, 560);
        }
        
        drawButton(360, 720, 350, 110, "#fc0", "ÈÅäÊà≤ÈñãÂßã");
        drawButton(360, 860, 350, 110, "#0fc", "ÈÅäÊà≤Ë™™Êòé");
        drawButton(360, 1000, 350, 110, "#f66", "ÊéíË°åÊ¶ú");
    }

    function drawRank() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.fillStyle = "#f66"; ctx.font = "bold 70px Arial"; ctx.textAlign = "center";
        ctx.fillText("ÂÇ≥Â•áÊéíË°åÊ¶ú", 360, 150);
        
        ctx.textAlign = "left"; ctx.font = "bold 28px Arial"; ctx.fillStyle = "#666";
        ctx.fillText("ÂêçÊ¨°  Áé©ÂÆ∂ÂêçÁ®±", 80, 250);
        ctx.textAlign = "right"; ctx.fillText("ÂàÜÊï∏ / Â±ÄÊï∏", 640, 250);

        leaderBoard.forEach((item, i) => {
            let y = 330 + i * 110;
            ctx.fillStyle = i === 0 ? "#fc0" : "#fff";
            ctx.textAlign = "left"; ctx.font = "bold 40px Arial";
            ctx.fillText(`${i+1}.`, 80, y);
            ctx.font = "bold 36px Arial";
            ctx.fillText(`${item.name}`, 160, y);
            
            ctx.textAlign = "right"; ctx.font = "bold 32px Arial";
            ctx.fillText(`${item.score.toLocaleString()}`, 640, y);
            ctx.font = "24px Arial"; ctx.fillStyle = "#aaa";
            ctx.fillText(`ÁîüÂ≠ò ${item.rounds+1} Â±Ä`, 640, y + 40);
        });

        if(leaderBoard.length === 0) {
            ctx.fillStyle = "#666"; ctx.textAlign = "center"; ctx.fillText("Â∞öÁÑ°Â∞çÂ±ÄÁ¥ÄÈåÑ", 360, 500);
        }
        drawButton(360, 1120, 300, 90, "#aaa", "Âõû‰∏ªÈÅ∏ÂñÆ");
    }

    function drawRules() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.fillStyle = "#fc0"; ctx.font = "bold 60px Arial"; ctx.textAlign = "center";
        ctx.fillText("ÈÅäÊà≤Ë™™Êòé", 360, 150);
        ctx.fillStyle = "#fff"; ctx.font = "28px Arial"; ctx.textAlign = "left";
        const rs = ["‚óè Ëµ∑Êâã 12 Ê≠•ÁîüÂëΩÔºåÊØèÊõ¥Êèõ‰∏ÄÂºµÊâ£ 1 Ê≠•„ÄÇ","‚óè ËÉ°ÁâåÂõûË£úËàáÁï™Êï∏Áõ∏ÂêåÁöÑÊ≠•Êï∏„ÄÇ","‚óè Èö®Â±ÄÊï∏Â¢ûÂä†ÔºåÈôêÊôÇÊúÉÂæû 60s Á∏ÆÊ∏õËá≥ 30s„ÄÇ","‚óè Á¨¶ÂêàÈ¢®Âúà/ÈñÄÈ¢®ÁöÑÂàªÂ≠êÔºåÈ°çÂ§ñ +1 Áï™„ÄÇ","‚óè ÈÄ£Á∫åËÉ°Áâå 3 Â±ÄÈ°çÂ§ñÂõûË£ú 2 Ê≠•„ÄÇ","‚óè Á©çÂàÜ = Âü∫Á§é + Áï™Êï∏x500 + ÁßíÊï∏x20 + Ê≠•Êï∏x100„ÄÇ"];
        rs.forEach((r, i) => ctx.fillText(r, 60, 300 + i * 70));
        drawButton(360, 1100, 300, 90, "#aaa", "Âõû‰∏ªÈÅ∏ÂñÆ");
    }

    function drawButton(x, y, w, h, col, txt) {
        ctx.fillStyle = col; ctx.beginPath(); ctx.roundRect(x - w/2, y - h/2, w, h, 20); ctx.fill();
        ctx.fillStyle = "#000"; ctx.font = "bold 45px Arial"; ctx.textAlign = "center"; ctx.fillText(txt, x, y + 15);
    }

    function drawResultOverlay() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.save(); ctx.translate(360, 640); ctx.scale(winInfo.scale, winInfo.scale);
        if (winInfo.isDraw) {
            ctx.fillStyle = "#aaa"; ctx.font = "bold 90px Arial"; ctx.textAlign="center"; ctx.fillText(`ÊµÅ Â±Ä`, 0, -100);
            winInfo.names.forEach((n, i) => { ctx.font = "30px Arial"; ctx.fillStyle = "#f44"; ctx.fillText(n, 0, i * 45); });
        } else {
            ctx.fillStyle = "#fff"; ctx.font = "bold 40px Arial"; ctx.textAlign="center"; ctx.fillText("Êú¨Â±ÄÁµêÁÆó", 0, -320);
            winInfo.names.forEach((n, i) => { ctx.textAlign = (i % 2 === 0) ? "right" : "left"; ctx.fillStyle = "#fff"; ctx.font = "26px Arial"; let offsetX = (i % 2 === 0) ? -40 : 40; let offsetY = -240 + Math.floor(i / 2) * 45; ctx.fillText(n, offsetX, offsetY); });
            ctx.fillStyle = "#fc0"; ctx.font = "bold 80px Arial"; ctx.textAlign="center"; ctx.fillText(`${winInfo.totalFan} Áï™!`, 0, -40);
            ctx.fillStyle = "#0f0"; ctx.font = "bold 35px Arial"; ctx.fillText(`ÁîüÂëΩÂõûË£ú +${winInfo.totalFan}`, 0, 40);
            if (winStreak > 0 && winStreak % 3 === 0) { ctx.fillStyle = "#0ff"; ctx.fillText(`ÈÄ£ËéäÁçéÂãµ +2`, 0, 90); }
            ctx.fillStyle = "rgba(255,255,255,0.08)"; ctx.beginPath(); ctx.roundRect(-280, 120, 560, 200, 15); ctx.fill();
            ctx.font = "22px Arial"; ctx.fillStyle = "#bbb"; ctx.textAlign = "left";
            winInfo.details.forEach((d, i) => { ctx.fillText(d, -240, 165 + i * 38); });
            ctx.fillStyle = "#fc0"; ctx.font = "bold 55px Arial"; ctx.textAlign = "center"; ctx.fillText(`Êú¨Ê¨°ÂæóÂàÜ +${lastGainedScore.toLocaleString()}`, 0, 380);
        }
        ctx.restore();
        if(winInfo.scale < 1) winInfo.scale += 0.05;
    }

    function drawTile(x, y, txt, color, w, h, isS) {
        ctx.save(); ctx.translate(x, y); ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 8); ctx.fill();
        ctx.strokeStyle = isS ? "#fc0" : "#bbb"; ctx.lineWidth = isS?6:2; ctx.stroke();
        ctx.fillStyle = color; ctx.font = `bold ${w*0.75}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(txt||'?', 0, 5); ctx.restore();
    }

    function drawOverlay(t, b, c) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0, 0, GW, GH);
        ctx.fillStyle = "#fff"; ctx.font = "bold 80px Arial"; ctx.textAlign = "center"; ctx.fillText(t, 360, 500);
        ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(200, 600, 320, 120, 20); ctx.fill();
        ctx.fillStyle = "#000"; ctx.font = "bold 50px Arial"; ctx.fillText(b, 360, 675);
    }

    function getCol(t) { return t==='MAN'?'#d32f2f':t==='TONG'?'#1976d2':t==='TIAO'?'#2e7d32':'#4a148c'; }
    function sortHand() { const order = {'MAN':0, 'TONG':1, 'TIAO':2, 'WIND':3, 'DRAGON':4}; hand.sort((a,b) => order[a.type] - order[b.type] || (a.val || a.txt).toString().localeCompare((b.val || b.txt).toString())); }

    function handleInput(e) {
        const rect = canvas.getBoundingClientRect(); const scale = canvas.width / GW;
        const mx = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / scale;
        const my = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) / scale;

        if (gameStatus === 'MENU') {
            if (mx > 185 && mx < 535 && my > 665 && my < 775) resetAndStart(true);
            if (mx > 185 && mx < 535 && my > 805 && my < 915) gameStatus = 'RULES';
            if (mx > 185 && mx < 535 && my > 945 && my < 1055) gameStatus = 'RANK';
            return;
        }
        if (gameStatus === 'RULES' || gameStatus === 'RANK') {
            if (mx > 210 && mx < 510 && my > 1055 && my < 1185) gameStatus = 'MENU';
            return;
        }
        if (gameStatus === 'FAIL') {
            saveScore(totalScore, gameCount);
            return gameStatus = 'MENU';
        }
        if (gameStatus === 'WIN_ANIM' && winInfo.scale >= 1) return resetAndStart(false);
        if (gameStatus !== 'PLAYING') return; 

        if (my > 880 && my < 960 && mx > GW/2 - 150 && mx < GW/2 + 150) { if (deck.length > 0) fillPool(); return; }
        hand.forEach((t, i) => { let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145; if (Math.abs(mx - tx) < 45 && Math.abs(my - ty) < 65) { if (selectedPoolIndex !== -1) performSwap(i, selectedPoolIndex); else { selectedHandIndex = (selectedHandIndex===i) ? -1 : i; playTone(600, 0.05, 0.3); } } });
        pool.forEach((p, i) => { if (Math.abs(mx - p.x) < 60 && Math.abs(my - p.y) < 80) { if (selectedHandIndex !== -1) performSwap(selectedHandIndex, i); else { selectedPoolIndex = (selectedPoolIndex===i) ? -1 : i; playTone(500, 0.05, 0.3); } } });
    }

    async function performSwap(hIdx, pIdx) {
        const pTile = { ...pool[pIdx] }; let tempHand = [...hand]; tempHand[hIdx] = pTile; let res = calculateTotalFan(tempHand);
        hand[hIdx] = pTile; pool.splice(pIdx, 1); selectedHandIndex = -1; selectedPoolIndex = -1; sortHand(); swapCount++;
        if (res) {
            const sum = res.reduce((a, b) => a + b.fan, 0); winStreak++; let bonusSteps = (winStreak > 0 && winStreak % 3 === 0) ? 2 : 0;
            const scoreBase = 1000, scoreFan = sum * 500, scoreTime = Math.floor(timeLeft) * 20, scoreMoves = movesLeft * 100;
            lastGainedScore = scoreBase + scoreFan + scoreTime + scoreMoves; totalScore += lastGainedScore;
            winInfo = { names: res.map(r => `${r.name} ${r.fan}Áï™`), totalFan: sum, scale: 0, isDraw: false, details: [`Âü∫Á§éËÉ°Áâå: +${scoreBase}`, `Áï™Êï∏Âä†Êàê ${sum}Áï™: +${scoreFan}`, `ÈÄüÂ∫¶ÁçéÂãµ ${Math.ceil(timeLeft)}Áßí: +${scoreTime}`, `ÁîüÂëΩÁçéÂãµ ${movesLeft}Ê≠•: +${scoreMoves}`] };
            movesLeft += (sum + bonusSteps); gameStatus = 'WIN_ANIM'; playTone(880, 0.5, 0.5);
        } else {
            movesLeft--; playTone(400, 0.1, 0.3); if (movesLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; } else if (deck.length === 0) checkFinalPossibility(); else if (pool.length === 0) fillPool();
        }
    }

    function triggerDrawGame(reason) { const isPenalized = swapCount < 3; if (isPenalized) movesLeft = Math.max(0, movesLeft - 3); winStreak = 0; winInfo = { names: isPenalized ? ["ÊèõÁâå‰∏çË∂≥3Ê¨°", "Ê∂àÊ•µËôïÁΩ∞ -3Ê≠•"] : [reason], totalFan: 0, scale: 0, isDraw: true, details: [] }; gameStatus = 'WIN_ANIM'; playTone(200, 0.8, 0.4); if (movesLeft <= 0 && isPenalized) gameStatus = 'FAIL'; }

    function loop() {
        const now = Date.now(), dt = (now - lastTimestamp) / 1000;
        lastTimestamp = now;
        if (gameStatus === 'PLAYING') {
            timeLeft -= dt;
            if (initialTime - timeLeft >= 5) {
                let tickInterval = (timeLeft <= 10) ? 0.5 : 1.0;
                if (lastTickTime - timeLeft >= tickInterval) { playTone((timeLeft <= 10) ? 1400 : 900, 0.06, 0.2); lastTickTime = timeLeft; }
            }
            if (timeLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; }
        }
        pool.forEach(p => { p.x += (p.targetX - p.x) * 0.15; p.y += (p.targetY - p.y) * 0.15; });
        hand.forEach((t, i) => { let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145; t.x += (tx - t.x) * 0.18; t.y += (ty - t.y) * 0.18; });
        draw();
        requestAnimationFrame(loop);
    }
    init();
</script>
</body>
</html>