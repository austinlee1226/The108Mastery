<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pixel JD - æ‹¾å…«é›€ï¼šç«¶æŠ€çµ‚æ¥µç‰ˆ</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; background: #051a10; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; position: fixed; width: 100%; font-family: sans-serif; }
        #canvasContainer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { background: radial-gradient(circle, #1a5e3a 0%, #0b2e1d 100%); display: block; touch-action: none; max-width: 100%; max-height: 100%; object-fit: contain; }
    </style>
</head>
<body>
<div id="canvasContainer"><canvas id="gameCanvas"></canvas></div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GW = 720, GH = 1280;

    const WINDS = ['ğŸ€€', 'ğŸ€', 'ğŸ€‚', 'ğŸ€ƒ']; 
    const TILES_DATA = {
        'MAN':    ['ğŸ€‡','ğŸ€ˆ','ğŸ€‰','ğŸ€Š','ğŸ€‹','ğŸ€Œ','ğŸ€','ğŸ€','ğŸ€'],
        'TONG':   ['ğŸ€™','ğŸ€š','ğŸ€›','ğŸ€œ','ğŸ€','ğŸ€','ğŸ€Ÿ','ğŸ€ ','ğŸ€¡'],
        'TIAO':   ['ğŸ€','ğŸ€‘','ğŸ€’','ğŸ€“','ğŸ€”','ğŸ€•','ğŸ€–','ğŸ€—','ğŸ€˜'],
        'WIND':   WINDS, 
        'DRAGON': ['ğŸ€„','ğŸ€…','ğŸ€†']
    };

    let gameStatus = 'START_SCREEN', totalScore = 0, movesLeft = 12, timeLeft = 60, initialTime = 60;
    let gameCount = 0, winStreak = 0, lastTickTime = 0;
    let roundWindIdx = 0, seatWindIdx = 0;
    let hand = [], pool = [], deck = [];
    let selectedHandIndex = -1, selectedPoolIndex = -1;
    let lastTimestamp = 0, swapCount = 0;
    let winInfo = { names: [], totalFan: 0, scale: 0, isDraw: false };

    function playTone(freq, dur, vol = 0.1) {
        if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = window.audioCtx.createOscillator();
        const g = window.audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, window.audioCtx.currentTime);
        g.gain.setValueAtTime(vol, window.audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, window.audioCtx.currentTime + dur);
        osc.connect(g); g.connect(window.audioCtx.destination);
        osc.start(); osc.stop(window.audioCtx.currentTime + dur);
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('pointerdown', handleInput);
        lastTimestamp = Date.now();
        requestAnimationFrame(loop);
    }

    function resize() {
        const scale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
        canvas.width = GW * scale; canvas.height = GH * scale;
        ctx.scale(scale, scale);
    }

    async function resetAndStart(isFullReset) {
        if(isFullReset) { 
            totalScore = 0; movesLeft = 12; gameCount = 0; winStreak = 0;
            roundWindIdx = 0; seatWindIdx = 0;
        } else {
            gameCount++;
            seatWindIdx = gameCount % 4;
            roundWindIdx = Math.floor(gameCount / 4) % 4;
        }
        
        // ä¿®æ­£å¾Œçš„é›£åº¦æ›²ç·š
        if (gameCount < 5) initialTime = 60;
        else if (gameCount < 15) initialTime = 60 - (Math.floor(gameCount / 5) * 5);
        else initialTime = Math.max(30, 50 - (Math.floor(gameCount / 10) * 5));
        
        timeLeft = initialTime;
        lastTickTime = initialTime; 
        selectedHandIndex = -1; selectedPoolIndex = -1; swapCount = 0;
        gameStatus = 'DEALING';
        
        let fullDeck = createDeck();
        let suitTiles = fullDeck.filter(t => ['MAN', 'TONG', 'TIAO'].includes(t.type));
        let wordTiles = fullDeck.filter(t => ['WIND', 'DRAGON'].includes(t.type));
        let wordCountForHand = Math.floor(Math.random() * 4) + 2; 
        hand = [];
        for(let i = 0; i < wordCountForHand; i++) hand.push(wordTiles.pop());
        while(hand.length < 14) hand.push(suitTiles.pop());
        deck = [...suitTiles, ...wordTiles].sort(() => Math.random() - 0.5);
        
        for(let i = 0; i < 14; i++) {
            let t = hand[i]; t.x = 800; t.y = 1100;
            if (i < 13) { playTone(500 + (i * 30), 0.08, 0.05); await new Promise(r => setTimeout(r, 60)); }
            else { playTone(800, 0.1, 0.1); }
        }
        sortHand(); fillPool(); gameStatus = 'PLAYING';
    }

    function createDeck() {
        let d = [];
        ['MAN', 'TONG', 'TIAO'].forEach(type => {
            for (let i = 1; i <= 9; i++) for (let n = 0; n < 4; n++) d.push({ type, val: i, txt: TILES_DATA[type][i-1] });
        });
        ['WIND', 'DRAGON'].forEach(type => TILES_DATA[type].forEach(txt => {
            for (let n = 0; n < 4; n++) d.push({ type, txt, val: null });
        }));
        return d.sort(() => Math.random() - 0.5);
    }

    function fillPool() {
        if (deck.length === 0) return; 
        pool = [];
        while(pool.length < 9 && deck.length > 0) {
            let t = deck.pop(); t.x = GW/2; t.y = GH/2;
            let i = pool.length;
            t.targetX = 230 + (i % 3) * 130; t.targetY = 480 + Math.floor(i / 3) * 145;
            pool.push(t);
        }
        if (deck.length === 0) checkFinalPossibility();
    }

    function checkFinalPossibility() {
        if (deck.length > 0) return;
        let canWin = false;
        for (let pTile of pool) {
            for (let i = 0; i < hand.length; i++) {
                let tempHand = JSON.parse(JSON.stringify(hand));
                tempHand[i] = pTile;
                if (calculateTotalFan(tempHand)) { canWin = true; break; }
            }
            if (canWin) break;
        }
        if (!canWin) triggerDrawGame("ç‰Œæ± ç„¡è§£ï¼Œè‡ªå‹•æµå±€");
    }

    function calculateTotalFan(h) {
        if (h.length !== 14) return null;
        let fanList = [];
        const counts = {}; 
        h.forEach(t => { const k = t.type + (t.val || t.txt); counts[k] = (counts[k] || 0) + 1; });

        if (checkThirteenOrphans(counts)) return [{ name: "åä¸‰ä¹ˆ", fan: 13 }];
        const hasSuit = h.some(t => ['MAN','TONG','TIAO'].includes(t.type));
        if (!hasSuit) return [{ name: "å­—ä¸€è‰²", fan: 13 }];

        let best = null;
        for (let key in counts) {
            if (counts[key] >= 2) {
                let tc = {...counts}; tc[key] -= 2;
                let m = []; if (findMianzi(tc, m)) { best = { jiang: key, mianzi: m }; break; }
            }
        }
        if (!best) return null;

        const mianzi = best.mianzi;
        const kezi = mianzi.filter(x => x.type === 'ke');
        if (checkChuuren(h)) return [{ name: "ä¹è“®å¯¶ç‡ˆ", fan: 13 }];

        const windsCount = kezi.filter(x => x.tile.startsWith('WIND')).length;
        if (windsCount === 4) fanList.push({ name: "å¤§å››å–œ", fan: 13 });
        else if (windsCount === 3 && best.jiang.startsWith('WIND')) fanList.push({ name: "å°å››å–œ", fan: 8 });

        const isAll19 = h.every(t => (t.val === 1 || t.val === 9) || ['WIND','DRAGON'].includes(t.type));
        if (isAll19 && kezi.length === 4) {
            if (h.every(t => (t.val === 1 || t.val === 9))) fanList.push({ name: "æ¸…ä¹ˆä¹", fan: 10 });
            else fanList.push({ name: "æ··ä¹ˆä¹", fan: 5 });
        }

        const dragonsCount = kezi.filter(x => x.tile.startsWith('DRAGON')).length;
        if (dragonsCount === 3) fanList.push({ name: "å¤§ä¸‰å…ƒ", fan: 8 });
        else if (dragonsCount === 2 && best.jiang.startsWith('DRAGON')) fanList.push({ name: "å°ä¸‰å…ƒ", fan: 5 });

        if (kezi.length === 4 && fanList.length === 0) fanList.push({ name: "å°å°èƒ¡", fan: 3 });
        const pureStatus = checkPureSuit(h);
        if (pureStatus === 'PURE') fanList.push({ name: "æ¸…ä¸€è‰²", fan: 7 });
        else if (pureStatus === 'MIXED' && !fanList.some(f => f.fan >= 5)) fanList.push({ name: "æ··ä¸€è‰²", fan: 3 });

        kezi.forEach(k => {
            if (k.tile === 'WIND' + WINDS[roundWindIdx]) fanList.push({ name: "åœˆé¢¨åˆ»", fan: 1 });
            if (k.tile === 'WIND' + WINDS[seatWindIdx]) fanList.push({ name: "é–€é¢¨åˆ»", fan: 1 });
            const val = parseInt(k.tile.replace(/[A-Z]/g, ''));
            if (val === 1 || val === 9) fanList.push({ name: "ä¹ˆä¹åˆ»", fan: 1 });
        });

        if (fanList.length === 0) fanList.push({ name: "é›èƒ¡", fan: 1 });
        return fanList;
    }

    function findMianzi(counts, m) {
        let keys = Object.keys(counts).filter(k => counts[k] > 0).sort();
        if (keys.length === 0) return true;
        let f = keys[0];
        if (counts[f] >= 3) {
            counts[f] -= 3; m.push({ type: 'ke', tile: f });
            if (findMianzi(counts, m)) return true;
            m.pop(); counts[f] += 3;
        }
        if (f.match(/MAN|TONG|TIAO/)) {
            let type = f.match(/MAN|TONG|TIAO/)[0], val = parseInt(f.replace(type, ''));
            let k2 = type + (val+1), k3 = type + (val+2);
            if (val <= 7 && counts[k2] > 0 && counts[k3] > 0) {
                counts[f]--; counts[k2]--; counts[k3]--;
                m.push({ type: 'shun', tile: f });
                if (findMianzi(counts, m)) return true;
                m.pop(); counts[f]++; counts[k2]++; counts[k3]++;
            }
        }
        return false;
    }

    function checkThirteenOrphans(counts) {
        const orphans = ['MAN1','MAN9','TONG1','TONG9','TIAO1','TIAO9','WINDğŸ€€','WINDğŸ€','WINDğŸ€‚','WINDğŸ€ƒ','DRAGONğŸ€„','DRAGONğŸ€…','DRAGONğŸ€†'];
        return orphans.every(o => counts[o] >= 1) && Object.keys(counts).length === 13;
    }

    function checkChuuren(h) {
        const suits = new Set(h.map(t => t.type));
        if (suits.size !== 1 || h.some(t => ['WIND','DRAGON'].includes(t.type))) return false;
        const vals = h.map(t => t.val).sort((a,b)=>a-b);
        const target = [1,1,1,2,3,4,5,6,7,8,9,9,9];
        for(let v of target) { let idx = vals.indexOf(v); if(idx === -1) return false; vals.splice(idx, 1); }
        return true;
    }

    function checkPureSuit(h) {
        const suits = new Set(h.filter(t => ['MAN','TONG','TIAO'].includes(t.type)).map(t => t.type));
        const hasWord = h.some(t => ['WIND','DRAGON'].includes(t.type));
        if (suits.size === 1 && !hasWord) return 'PURE';
        if (suits.size === 1 && hasWord) return 'MIXED';
        return 'NONE';
    }

    function draw() {
        ctx.clearRect(0, 0, GW, GH);
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0, 0, GW, 240);
        ctx.fillStyle = "#fff"; ctx.font = "bold 42px Arial"; ctx.textAlign = "center";
        ctx.fillText(`æ‹¾å…«é›€ï¼šç«¶æŠ€çµ‚æ¥µç‰ˆ`, 360, 60);
        ctx.font = "bold 28px Arial"; ctx.fillStyle = "#aaa";
        ctx.fillText(`${WINDS[roundWindIdx]}é¢¨åœˆ / é–€é¢¨ï¼š${WINDS[seatWindIdx]}`, 360, 105);
        ctx.font = "bold 32px Arial";
        ctx.fillStyle = movesLeft <= 3 ? "#f44" : "#0fc";
        ctx.fillText(`ç”Ÿå‘½: ${movesLeft}`, 180, 160);
        ctx.fillStyle = (timeLeft <= 10) ? "#f44" : "#fc0";
        ctx.fillText(`é™æ™‚: ${Math.ceil(timeLeft)}s`, 540, 160);

        pool.forEach((p, i) => drawTile(p.x, p.y, p.txt, getCol(p.type), 115, 160, i === selectedPoolIndex));

        if (gameStatus === 'PLAYING') {
            ctx.fillStyle = (deck.length > 0) ? "#e64a19" : "#333";
            ctx.beginPath(); ctx.roundRect(GW/2 - 150, 880, 300, 80, 15); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 32px Arial"; ctx.textAlign = "center";
            ctx.fillText(deck.length > 0 ? "æ›´æ›ç‰Œæ± " : "ç‰Œåº«ç©ºäº†", GW/2, 932);
        }

        ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0, 970, GW, 310);
        hand.forEach((t, i) => {
            let isS = (i === selectedHandIndex);
            drawTile(t.x, t.y - (isS ? 40 : 0), t.txt, getCol(t.type), 88, 125, isS);
        });

        if (gameStatus === 'WIN_ANIM') drawResultOverlay();
        if (gameStatus === 'START_SCREEN') drawOverlay("Pixel JD æ‹¾å…«é›€", "é–‹å§‹éŠæˆ²", "#fc0");
        if (gameStatus === 'FAIL') drawOverlay("ç”Ÿå‘½è€—ç›¡", "é‡æ–°æŒ‘æˆ°", "#f44");
    }

    function drawResultOverlay() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.save(); ctx.translate(360, 640); ctx.scale(winInfo.scale, winInfo.scale);
        if (winInfo.isDraw) {
            ctx.fillStyle = "#aaa"; ctx.font = "bold 90px Arial"; ctx.textAlign="center"; ctx.fillText(`æµ å±€`, 0, -100);
            winInfo.names.forEach((n, i) => { ctx.font = "30px Arial"; ctx.fillStyle = "#f44"; ctx.fillText(n, 0, i * 45); });
        } else {
            ctx.fillStyle = "#fc0"; ctx.font = "bold 80px Arial"; ctx.textAlign="center"; ctx.fillText(`${winInfo.totalFan} ç•ª!`, 0, -150);
            winInfo.names.forEach((n, i) => { ctx.font = "28px Arial"; ctx.fillStyle = "#fff"; ctx.fillText(n, 0, i * 40 - 50); });
            ctx.fillStyle = "#0f0"; ctx.font = "bold 35px Arial"; ctx.fillText(`ç”Ÿå‘½å›è£œ +${winInfo.totalFan}`, 0, 180);
            if (winStreak > 0 && winStreak % 3 === 0) { ctx.fillStyle = "#0ff"; ctx.fillText(`é€£èŠçå‹µ +2!`, 0, 240); }
        }
        ctx.restore();
        if(winInfo.scale < 1) winInfo.scale += 0.05;
    }

    function drawTile(x, y, txt, color, w, h, isS) {
        ctx.save(); ctx.translate(x, y);
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 8); ctx.fill();
        ctx.strokeStyle = isS ? "#fc0" : "#bbb"; ctx.lineWidth = isS?6:2; ctx.stroke();
        ctx.fillStyle = color; ctx.font = `bold ${w*0.75}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(txt||'?', 0, 5); ctx.restore();
    }

    function drawOverlay(t, b, c) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0, 0, GW, GH);
        ctx.fillStyle = "#fff"; ctx.font = "bold 80px Arial"; ctx.textAlign = "center"; ctx.fillText(t, 360, 500);
        ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(200, 600, 320, 120, 20); ctx.fill();
        ctx.fillStyle = "#000"; ctx.font = "bold 50px Arial"; ctx.fillText(b, 360, 675);
    }

    function getCol(t) { return t==='MAN'?'#d32f2f':t==='TONG'?'#1976d2':t==='TIAO'?'#2e7d32':'#4a148c'; }
    function sortHand() { const order = {'MAN':0, 'TONG':1, 'TIAO':2, 'WIND':3, 'DRAGON':4}; hand.sort((a,b) => order[a.type] - order[b.type] || (a.val || a.txt).toString().localeCompare((b.val || b.txt).toString())); }

    function handleInput(e) {
        const rect = canvas.getBoundingClientRect(); const scale = canvas.width / GW;
        const mx = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / scale;
        const my = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) / scale;
        if (gameStatus === 'START_SCREEN' || gameStatus === 'FAIL') return resetAndStart(true);
        if (gameStatus === 'WIN_ANIM' && winInfo.scale >= 1) return resetAndStart(false);
        if (gameStatus !== 'PLAYING') return;
        if (my > 880 && my < 960 && mx > GW/2 - 150 && mx < GW/2 + 150) { if (deck.length > 0) fillPool(); return; }
        hand.forEach((t, i) => { let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145; if (Math.abs(mx - tx) < 45 && Math.abs(my - ty) < 65) { if (selectedPoolIndex !== -1) performSwap(i, selectedPoolIndex); else { selectedHandIndex = (selectedHandIndex===i) ? -1 : i; playTone(600, 0.05); } } });
        pool.forEach((p, i) => { if (Math.abs(mx - p.x) < 60 && Math.abs(my - p.y) < 80) { if (selectedHandIndex !== -1) performSwap(selectedHandIndex, i); else { selectedPoolIndex = (selectedPoolIndex===i) ? -1 : i; playTone(500, 0.05); } } });
    }

    async function performSwap(hIdx, pIdx) {
        const pTile = { ...pool[pIdx] }; let tempHand = [...hand]; tempHand[hIdx] = pTile; let res = calculateTotalFan(tempHand);
        hand[hIdx] = pTile; pool.splice(pIdx, 1); selectedHandIndex = -1; selectedPoolIndex = -1; sortHand(); swapCount++;
        if (res) { const sum = res.reduce((a, b) => a + b.fan, 0); winStreak++; let bonus = (winStreak > 0 && winStreak % 3 === 0) ? 2 : 0; winInfo = { names: res.map(r => `${r.name} ${r.fan}ç•ª`), totalFan: sum, scale: 0, isDraw: false }; movesLeft += (sum + bonus); gameStatus = 'WIN_ANIM'; playTone(880, 0.5); }
        else { movesLeft--; playTone(400, 0.1); if (movesLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; } else if (deck.length === 0) checkFinalPossibility(); else if (pool.length === 0) fillPool(); }
    }

    function triggerDrawGame(reason) { const isPenalized = swapCount < 3; if (isPenalized) movesLeft = Math.max(0, movesLeft - 3); winStreak = 0; winInfo = { names: isPenalized ? ["æ›ç‰Œä¸è¶³3æ¬¡", "æ¶ˆæ¥µè™•ç½° -3æ­¥"] : [reason], totalFan: 0, scale: 0, isDraw: true }; gameStatus = 'WIN_ANIM'; playTone(200, 0.8); if (movesLeft <= 0 && isPenalized) gameStatus = 'FAIL'; }

    function loop() {
        const now = Date.now(), dt = (now - lastTimestamp) / 1000;
        lastTimestamp = now;
        if (gameStatus === 'PLAYING') {
            timeLeft -= dt;
            
            // æ™‚é–“è²æ•ˆé‚è¼¯
            let elapsed = initialTime - timeLeft;
            if (elapsed >= 5) {
                let tickInterval = (timeLeft <= 10) ? 0.5 : 1.0;
                if (lastTickTime - timeLeft >= tickInterval) {
                    let freq = (timeLeft <= 10) ? 1200 : 800; // æœ€å¾Œ10ç§’éŸ³èª¿è®Šé«˜
                    playTone(freq, 0.05, 0.03);
                    lastTickTime = timeLeft;
                }
            }
            if (timeLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; }
        }
        pool.forEach(p => { p.x += (p.targetX - p.x) * 0.15; p.y += (p.targetY - p.y) * 0.15; });
        hand.forEach((t, i) => { let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145; t.x += (tx - t.x) * 0.18; t.y += (ty - t.y) * 0.18; });
        draw();
        requestAnimationFrame(loop);
    }
    init();
</script>
</body>
</html>