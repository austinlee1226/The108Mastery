<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pixel JD - ÊãæÂÖ´ÈõÄÔºöÈ¢®Èõ≤Á´∂ÊäÄÁâà</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; background: #051a10; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; position: fixed; width: 100%; font-family: sans-serif; }
        #canvasContainer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { background: radial-gradient(circle, #1a5e3a 0%, #0b2e1d 100%); display: block; touch-action: none; max-width: 100%; max-height: 100%; object-fit: contain; }
    </style>
</head>
<body>

<div id="canvasContainer">
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GW = 720, GH = 1280;

    const WINDS = ['üÄÄ', 'üÄÅ', 'üÄÇ', 'üÄÉ']; // Êù±ÂçóË•øÂåó
    const TILES_DATA = {
        'MAN':    ['üÄá','üÄà','üÄâ','üÄä','üÄã','üÄå','üÄç','üÄé','üÄè'],
        'TONG':   ['üÄô','üÄö','üÄõ','üÄú','üÄù','üÄû','üÄü','üÄ†','üÄ°'],
        'TIAO':   ['üÄê','üÄë','üÄí','üÄì','üÄî','üÄï','üÄñ','üÄó','üÄò'],
        'WIND':   WINDS, 
        'DRAGON': ['üÄÑ','üÄÖ','üÄÜ']
    };

    let gameStatus = 'START_SCREEN', totalScore = 0, movesLeft = 12, timeLeft = 60;
    let gameCount = 0, winStreak = 0;
    let roundWindIdx = 0, seatWindIdx = 0;
    let hand = [], pool = [], deck = [];
    let selectedHandIndex = -1, selectedPoolIndex = -1;
    let lastTimestamp = 0, swapCount = 0;
    let winInfo = { names: [], totalFan: 0, scale: 0, isDraw: false };

    function playTone(freq, dur, vol = 0.1) {
        if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = window.audioCtx.createOscillator();
        const g = window.audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, window.audioCtx.currentTime);
        g.gain.setValueAtTime(vol, window.audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, window.audioCtx.currentTime + dur);
        osc.connect(g); g.connect(window.audioCtx.destination);
        osc.start(); osc.stop(window.audioCtx.currentTime + dur);
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('pointerdown', handleInput);
        lastTimestamp = Date.now();
        requestAnimationFrame(loop);
    }

    function resize() {
        const scale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
        canvas.width = GW * scale; canvas.height = GH * scale;
        ctx.scale(scale, scale);
    }

    async function resetAndStart(isFullReset) {
        if(isFullReset) { 
            totalScore = 0; movesLeft = 12; gameCount = 0; winStreak = 0;
            roundWindIdx = 0; seatWindIdx = 0;
        } else {
            gameCount++;
            seatWindIdx = gameCount % 4;
            roundWindIdx = Math.floor(gameCount / 4) % 4;
        }
        
        // Â±ÄÊï∏Âä†Ê¨äÔºöÊØè 10 Â±ÄÊ∏õ 5 ÁßíÔºåÊúÄ‰Ωé 30 Áßí
        timeLeft = Math.max(30, 60 - Math.floor(gameCount / 10) * 5);
        
        selectedHandIndex = -1; selectedPoolIndex = -1; swapCount = 0;
        gameStatus = 'DEALING';
        
        let fullDeck = createDeck();
        let suitTiles = fullDeck.filter(t => ['MAN', 'TONG', 'TIAO'].includes(t.type));
        let wordTiles = fullDeck.filter(t => ['WIND', 'DRAGON'].includes(t.type));
        let wordCountForHand = Math.floor(Math.random() * 4) + 2; 
        hand = [];
        for(let i = 0; i < wordCountForHand; i++) hand.push(wordTiles.pop());
        while(hand.length < 14) hand.push(suitTiles.pop());
        deck = [...suitTiles, ...wordTiles].sort(() => Math.random() - 0.5);
        
        for(let i = 0; i < 14; i++) {
            let t = hand[i]; t.x = 800; t.y = 1100;
            if (i < 13) { playTone(500 + (i * 30), 0.08, 0.05); await new Promise(r => setTimeout(r, 60)); }
            else { playTone(800, 0.1, 0.1); }
        }
        sortHand(); fillPool(); gameStatus = 'PLAYING';
    }

    function createDeck() {
        let d = [];
        ['MAN', 'TONG', 'TIAO'].forEach(type => {
            for (let i = 1; i <= 9; i++) for (let n = 0; n < 4; n++) d.push({ type, val: i, txt: TILES_DATA[type][i-1] });
        });
        ['WIND', 'DRAGON'].forEach(type => TILES_DATA[type].forEach(txt => {
            for (let n = 0; n < 4; n++) d.push({ type, txt, val: null });
        }));
        return d.sort(() => Math.random() - 0.5);
    }

    function fillPool() {
        if (deck.length === 0) return; 
        pool = [];
        while(pool.length < 9 && deck.length > 0) {
            let t = deck.pop(); t.x = GW/2; t.y = GH/2;
            let i = pool.length;
            t.targetX = 230 + (i % 3) * 130; t.targetY = 480 + Math.floor(i / 3) * 145;
            pool.push(t);
        }
        if (deck.length === 0) checkFinalPossibility();
    }

    function checkFinalPossibility() {
        if (deck.length > 0) return;
        let canWin = false;
        for (let pTile of pool) {
            for (let i = 0; i < hand.length; i++) {
                let tempHand = JSON.parse(JSON.stringify(hand));
                tempHand[i] = pTile;
                if (calculateTotalFan(tempHand)) { canWin = true; break; }
            }
            if (canWin) break;
        }
        if (!canWin) triggerDrawGame("ÁâåÊ±†ÁÑ°Ëß£ÔºåËá™ÂãïÊµÅÂ±Ä");
    }

    function calculateTotalFan(h) {
        if (h.length !== 14) return null;
        let fanList = [];
        const counts = {}; 
        h.forEach(t => { 
            const k = t.type + (t.val || t.txt); 
            counts[k] = (counts[k] || 0) + 1; 
        });

        // 1. ÂçÅ‰∏â‰πà (13Áï™)
        if (checkThirteenOrphans(counts)) return [{ name: "ÂçÅ‰∏â‰πà", fan: 13 }];

        // 2. Â≠ó‰∏ÄËâ≤ (13Áï™)
        const hasSuit = h.some(t => ['MAN','TONG','TIAO'].includes(t.type));
        if (!hasSuit) return [{ name: "Â≠ó‰∏ÄËâ≤", fan: 13 }];

        let best = null;
        for (let key in counts) {
            if (counts[key] >= 2) {
                let tc = {...counts}; tc[key] -= 2;
                let m = []; if (findMianzi(tc, m)) { best = { jiang: key, mianzi: m }; break; }
            }
        }
        if (!best) return null;

        const mianzi = best.mianzi;
        const kezi = mianzi.filter(x => x.type === 'ke');
        const keziCount = kezi.length;

        // ÁâπÊÆäÂ§ßÁâåÂà§ÂÆö
        // ‰πùËìÆÂØ∂Ááà (13Áï™)
        const chuun = checkChuuren(h);
        if (chuun) return [{ name: "‰πùËìÆÂØ∂Ááà", fan: 13 }];

        // Â§ßÂõõÂñú (13Áï™) / Â∞èÂõõÂñú (8Áï™)
        const windsCount = kezi.filter(x => x.tile.startsWith('WIND')).length;
        if (windsCount === 4) fanList.push({ name: "Â§ßÂõõÂñú", fan: 13 });
        else if (windsCount === 3 && best.jiang.startsWith('WIND')) fanList.push({ name: "Â∞èÂõõÂñú", fan: 8 });

        // Ê∏Ö‰πà‰πù (10Áï™) / Ê∑∑‰πà‰πù (5Áï™)
        const isAll19 = h.every(t => (t.val === 1 || t.val === 9) || ['WIND','DRAGON'].includes(t.type));
        if (isAll19 && keziCount === 4) {
            if (!hasSuit) {} // Â≠ó‰∏ÄËâ≤ÂÑ™ÂÖà
            else if (h.every(t => (t.val === 1 || t.val === 9))) fanList.push({ name: "Ê∏Ö‰πà‰πù", fan: 10 });
            else fanList.push({ name: "Ê∑∑‰πà‰πù", fan: 5 });
        }

        // Â§ß‰∏âÂÖÉ (8Áï™) / Â∞è‰∏âÂÖÉ (5Áï™)
        const dragonsCount = kezi.filter(x => x.tile.startsWith('DRAGON')).length;
        if (dragonsCount === 3) fanList.push({ name: "Â§ß‰∏âÂÖÉ", fan: 8 });
        else if (dragonsCount === 2 && best.jiang.startsWith('DRAGON')) fanList.push({ name: "Â∞è‰∏âÂÖÉ", fan: 5 });

        // Âü∫Êú¨ÁâåÂûã
        if (keziCount === 4 && fanList.length === 0) fanList.push({ name: "Â∞çÂ∞çËÉ°", fan: 3 });
        const pureStatus = checkPureSuit(h);
        if (pureStatus === 'PURE') fanList.push({ name: "Ê∏Ö‰∏ÄËâ≤", fan: 7 });
        else if (pureStatus === 'MIXED' && !fanList.some(f => f.fan >= 5)) fanList.push({ name: "Ê∑∑‰∏ÄËâ≤", fan: 3 });

        // È¢®Âúà„ÄÅÈñÄÈ¢®„ÄÅ‰πà‰πùÂàª
        kezi.forEach(k => {
            if (k.tile === 'WIND' + WINDS[roundWindIdx]) fanList.push({ name: "ÂúàÈ¢®Âàª", fan: 1 });
            if (k.tile === 'WIND' + WINDS[seatWindIdx]) fanList.push({ name: "ÈñÄÈ¢®Âàª", fan: 1 });
            const val = parseInt(k.tile.replace(/[A-Z]/g, ''));
            if (val === 1 || val === 9) fanList.push({ name: "‰πà‰πùÂàª", fan: 1 });
        });

        if (fanList.length === 0) {
            const hasWord = h.some(t => ['WIND','DRAGON'].includes(t.type));
            if (keziCount === 0 && !hasWord) fanList.push({ name: "Âπ≥ËÉ°", fan: 1 });
            else fanList.push({ name: "ÈõûËÉ°", fan: 1 });
        }
        return fanList;
    }

    function findMianzi(counts, m) {
        let keys = Object.keys(counts).filter(k => counts[k] > 0).sort();
        if (keys.length === 0) return true;
        let f = keys[0];
        if (counts[f] >= 3) {
            counts[f] -= 3; m.push({ type: 'ke', tile: f });
            if (findMianzi(counts, m)) return true;
            m.pop(); counts[f] += 3;
        }
        if (f.match(/MAN|TONG|TIAO/)) {
            let type = f.match(/MAN|TONG|TIAO/)[0], val = parseInt(f.replace(type, ''));
            let k2 = type + (val+1), k3 = type + (val+2);
            if (val <= 7 && counts[k2] > 0 && counts[k3] > 0) {
                counts[f]--; counts[k2]--; counts[k3]--;
                m.push({ type: 'shun', tile: f });
                if (findMianzi(counts, m)) return true;
                m.pop(); counts[f]++; counts[k2]++; counts[k3]++;
            }
        }
        return false;
    }

    function checkThirteenOrphans(counts) {
        const orphans = ['MAN1','MAN9','TONG1','TONG9','TIAO1','TIAO9','WINDüÄÄ','WINDüÄÅ','WINDüÄÇ','WINDüÄÉ','DRAGONüÄÑ','DRAGONüÄÖ','DRAGONüÄÜ'];
        return orphans.every(o => counts[o] >= 1) && Object.keys(counts).length === 13;
    }

    function checkChuuren(h) {
        const suits = new Set(h.map(t => t.type));
        if (suits.size !== 1 || h.some(t => ['WIND','DRAGON'].includes(t.type))) return false;
        const vals = h.map(t => t.val).sort((a,b)=>a-b);
        const target = [1,1,1,2,3,4,5,6,7,8,9,9,9];
        for(let v of target) {
            let idx = vals.indexOf(v);
            if(idx === -1) return false;
            vals.splice(idx, 1);
        }
        return true;
    }

    function checkPureSuit(h) {
        const suits = new Set(h.filter(t => ['MAN','TONG','TIAO'].includes(t.type)).map(t => t.type));
        const hasWord = h.some(t => ['WIND','DRAGON'].includes(t.type));
        if (suits.size === 1 && !hasWord) return 'PURE';
        if (suits.size === 1 && hasWord) return 'MIXED';
        return 'NONE';
    }

    function draw() {
        ctx.clearRect(0, 0, GW, GH);
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, GW, 240);

        ctx.fillStyle = "#fff"; ctx.font = "bold 42px Arial"; ctx.textAlign = "center";
        ctx.fillText(`ÊãæÂÖ´ÈõÄÔºöÁîüÂ≠òÁ´∂ÊäÄ`, 360, 60);

        ctx.font = "bold 28px Arial"; ctx.fillStyle = "#aaa";
        ctx.fillText(`${WINDS[roundWindIdx]}È¢®Âúà / ÈñÄÈ¢®Ôºö${WINDS[seatWindIdx]}`, 360, 105);

        ctx.font = "bold 32px Arial";
        ctx.fillStyle = movesLeft <= 3 ? "#f44" : "#0fc";
        ctx.fillText(`ÁîüÂëΩ: ${movesLeft}`, 180, 160);
        ctx.fillStyle = "#fc0";
        ctx.fillText(`ÈôêÊôÇ: ${Math.ceil(timeLeft)}s`, 540, 160);

        // ÁâåÂ∫´Ë≥áË®ä
        ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fillRect(20, 185, GW-40, 45);
        const c = { MAN: 0, TONG: 0, TIAO: 0, WORD: 0 };
        deck.forEach(t => { if(['WIND', 'DRAGON'].includes(t.type)) c.WORD++; else c[t.type]++; });
        ctx.font = "20px Arial"; ctx.textAlign = "left"; ctx.fillStyle = "#888";
        ctx.fillText(`ÁâåÂ∫´: ${deck.length}`, 50, 215);
        ctx.textAlign = "right";
        ctx.fillStyle = "#d32f2f"; ctx.fillText(`Ëê¨:${c.MAN}`, 340, 215);
        ctx.fillStyle = "#1976d2"; ctx.fillText(`Á≠í:${c.TONG}`, 440, 215);
        ctx.fillStyle = "#2e7d32"; ctx.fillText(`Ê¢ù:${c.TIAO}`, 540, 215);
        ctx.fillStyle = "#fc0"; ctx.fillText(`Â≠ó:${c.WORD}`, 660, 215);

        pool.forEach((p, i) => drawTile(p.x, p.y, p.txt, getCol(p.type), 115, 160, i === selectedPoolIndex));

        if (gameStatus === 'PLAYING') {
            ctx.fillStyle = (deck.length > 0) ? "#e64a19" : "#333";
            ctx.beginPath(); ctx.roundRect(GW/2 - 150, 880, 300, 80, 15); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "bold 32px Arial"; ctx.textAlign = "center";
            ctx.fillText(deck.length > 0 ? "Êõ¥ÊèõÁâåÊ±†" : "ÁâåÂ∫´Á©∫‰∫Ü", GW/2, 932);
        }

        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.fillRect(0, 970, GW, 310);
        hand.forEach((t, i) => {
            let isS = (i === selectedHandIndex);
            drawTile(t.x, t.y - (isS ? 40 : 0), t.txt, getCol(t.type), 88, 125, isS);
        });

        if (gameStatus === 'WIN_ANIM') drawResultOverlay();
        if (gameStatus === 'START_SCREEN') drawOverlay("Pixel JD ÊãæÂÖ´ÈõÄ", "ÈñãÂßãÈÅäÊà≤", "#fc0");
        if (gameStatus === 'FAIL') drawOverlay("ÁîüÂëΩËÄóÁõ°", "ÈáçÊñ∞ÊåëÊà∞", "#f44");
    }

    function drawResultOverlay() {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.save(); ctx.translate(360, 640); ctx.scale(winInfo.scale, winInfo.scale);
        if (winInfo.isDraw) {
            ctx.fillStyle = "#aaa"; ctx.font = "bold 90px Arial"; ctx.textAlign="center"; ctx.fillText(`ÊµÅ Â±Ä`, 0, -100);
            ctx.font = "30px Arial"; ctx.fillStyle = "#f44";
            winInfo.names.forEach((n, i) => ctx.fillText(n, 0, i * 45));
        } else {
            ctx.fillStyle = "#fc0"; ctx.font = "bold 80px Arial"; ctx.textAlign="center"; ctx.fillText(`${winInfo.totalFan} Áï™!`, 0, -150);
            ctx.font = "28px Arial"; ctx.fillStyle = "#fff";
            winInfo.names.forEach((n, i) => ctx.fillText(n, 0, i * 40 - 50));
            ctx.fillStyle = "#0f0"; ctx.font = "bold 35px Arial";
            ctx.fillText(`ÁîüÂëΩÂõûË£ú +${winInfo.totalFan}`, 0, 180);
            if (winStreak > 0 && winStreak % 3 === 0) {
                ctx.fillStyle = "#0ff"; ctx.fillText(`ÈÄ£ËéäÁçéÂãµ +2!`, 0, 240);
            }
        }
        ctx.restore();
        if(winInfo.scale < 1) winInfo.scale += 0.05;
    }

    function drawTile(x, y, txt, color, w, h, isS) {
        ctx.save(); ctx.translate(x, y);
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 8); ctx.fill();
        ctx.strokeStyle = isS ? "#fc0" : "#bbb"; ctx.lineWidth = isS?6:2; ctx.stroke();
        ctx.fillStyle = color; ctx.font = `bold ${w*0.75}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(txt||'?', 0, 5); ctx.restore();
    }

    function drawOverlay(t, b, c) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0, 0, GW, GH);
        ctx.fillStyle = "#fff"; ctx.font = "bold 80px Arial"; ctx.textAlign = "center"; ctx.fillText(t, 360, 500);
        ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(200, 600, 320, 120, 20); ctx.fill();
        ctx.fillStyle = "#000"; ctx.font = "bold 50px Arial"; ctx.fillText(b, 360, 675);
    }

    function getCol(t) { return t==='MAN'?'#d32f2f':t==='TONG'?'#1976d2':t==='TIAO'?'#2e7d32':'#4a148c'; }

    function sortHand() {
        const order = {'MAN':0, 'TONG':1, 'TIAO':2, 'WIND':3, 'DRAGON':4};
        hand.sort((a,b) => order[a.type] - order[b.type] || (a.val || a.txt).toString().localeCompare((b.val || b.txt).toString()));
    }

    function handleInput(e) {
        const rect = canvas.getBoundingClientRect();
        const scale = canvas.width / GW;
        const mx = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / scale;
        const my = ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) / scale;

        if (gameStatus === 'START_SCREEN' || gameStatus === 'FAIL') return resetAndStart(true);
        if (gameStatus === 'WIN_ANIM' && winInfo.scale >= 1) return resetAndStart(false);
        if (gameStatus !== 'PLAYING') return;

        if (my > 880 && my < 960 && mx > GW/2 - 150 && mx < GW/2 + 150) {
            if (deck.length > 0) fillPool();
            return;
        }

        hand.forEach((t, i) => {
            let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145;
            if (Math.abs(mx - tx) < 45 && Math.abs(my - ty) < 65) {
                if (selectedPoolIndex !== -1) performSwap(i, selectedPoolIndex);
                else { selectedHandIndex = (selectedHandIndex===i) ? -1 : i; playTone(600, 0.05); }
            }
        });

        pool.forEach((p, i) => {
            if (Math.abs(mx - p.x) < 60 && Math.abs(my - p.y) < 80) {
                if (selectedHandIndex !== -1) performSwap(selectedHandIndex, i);
                else { selectedPoolIndex = (selectedPoolIndex===i) ? -1 : i; playTone(500, 0.05); }
            }
        });
    }

    async function performSwap(hIdx, pIdx) {
        const pTile = { ...pool[pIdx] };
        let tempHand = [...hand]; tempHand[hIdx] = pTile;
        let res = calculateTotalFan(tempHand);
        
        hand[hIdx] = pTile; pool.splice(pIdx, 1);
        selectedHandIndex = -1; selectedPoolIndex = -1;
        sortHand();
        swapCount++;

        if (res) {
            const sum = res.reduce((a, b) => a + b.fan, 0);
            winStreak++;
            let bonus = (winStreak > 0 && winStreak % 3 === 0) ? 2 : 0;
            winInfo = { names: res.map(r => `${r.name} ${r.fan}Áï™`), totalFan: sum, scale: 0, isDraw: false };
            movesLeft += (sum + bonus); 
            gameStatus = 'WIN_ANIM'; 
            playTone(880, 0.5);
        } else {
            movesLeft--; playTone(400, 0.1);
            if (movesLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; }
            else if (deck.length === 0) checkFinalPossibility(); 
            else if (pool.length === 0) fillPool();
        }
    }

    function triggerDrawGame(reason) {
        const isPenalized = swapCount < 3;
        if (isPenalized) movesLeft = Math.max(0, movesLeft - 3);
        winStreak = 0;
        winInfo = { names: isPenalized ? ["ÊèõÁâå‰∏çË∂≥3Ê¨°", "Ê∂àÊ•µËôïÁΩ∞ -3Ê≠•"] : [reason], totalFan: 0, scale: 0, isDraw: true };
        gameStatus = 'WIN_ANIM'; playTone(200, 0.8);
        if (movesLeft <= 0 && isPenalized) gameStatus = 'FAIL';
    }

    function loop() {
        const now = Date.now(), dt = (now - lastTimestamp) / 1000;
        lastTimestamp = now;
        if (gameStatus === 'PLAYING') {
            timeLeft -= dt;
            if (timeLeft <= 0) { gameStatus = 'FAIL'; winStreak = 0; }
        }
        pool.forEach(p => { p.x += (p.targetX - p.x) * 0.15; p.y += (p.targetY - p.y) * 0.15; });
        hand.forEach((t, i) => { 
            let tx = 88 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145;
            t.x += (tx - t.x) * 0.18; t.y += (ty - t.y) * 0.18;
        });
        draw();
        requestAnimationFrame(loop);
    }
    init();
</script>
</body>
</html>