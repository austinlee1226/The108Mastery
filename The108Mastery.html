<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÊãæÂÖ´ÈõÄÔºöÁÆóÁï™Á´∂ÊäÄ (Â∫ïÂè∞Âº∑ÂåñÁâà)</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; background: #051a10; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; position: fixed; width: 100%; font-family: sans-serif; }
        #canvasContainer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        canvas { background: radial-gradient(circle, #1a5e3a 0%, #0b2e1d 100%); display: block; touch-action: none; max-width: 100%; max-height: 100%; object-fit: contain; }
    </style>
</head>
<body>
<div id="canvasContainer">
    <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GW = 720, GH = 1280;

let gameStatus = 'START_SCREEN'; 
let totalScore = 0, movesLeft = 10, timeLeft = 60;
let hand = [], pool = [], deck = [], flowersWon = [];
let swapActionCount = 0, gameCount = 0; 
let selectedHandIndex = -1, selectedPoolIndex = -1, lastTimestamp = 0;
let winInfo = { names: [], totalTai: 0, curScore: 0, scale: 0, penalty: 0, rewardMoves: 0 };
let drawGamePending = false; 

const WIND_ORDER = ['üÄÄ', 'üÄÅ', 'üÄÇ', 'üÄÉ'];
const FLOWER_NAMES = ['Êò•', 'Â§è', 'Áßã', 'ÂÜ¨', 'Ê¢Ö', 'Ëò≠', 'Á´π', 'Ëèä'];
let roundWind = 'üÄÄ', seatWind = 'üÄÄ';

const TILES_DATA = {
    'MAN':  ['üÄá','üÄà','üÄâ','üÄä','üÄã','üÄå','üÄç','üÄé','üÄè'],
    'TONG': ['üÄô','üÄö','üÄõ','üÄú','üÄù','üÄû','üÄü','üÄ†','üÄ°'],
    'TIAO': ['üÄê','üÄë','üÄí','üÄì','üÄî','üÄï','üÄñ','üÄó','üÄò'],
    'WIND': ['üÄÄ','üÄÅ','üÄÇ','üÄÉ'], 
    'DRAGON':['üÄÑ','üÄÖ','üÄÜ'],    
    'FLOWER':['üÄ¢','üÄ£','üÄ§','üÄ•','üÄ¶','üÄß','üÄ®','üÄ©'] 
};

const delay = ms => new Promise(res => setTimeout(res, ms));

function playTone(freq, dur, vol = 0.1) {
    if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = window.audioCtx.createOscillator();
    const g = window.audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, window.audioCtx.currentTime);
    g.gain.setValueAtTime(vol, window.audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, window.audioCtx.currentTime + dur);
    osc.connect(g); g.connect(window.audioCtx.destination);
    osc.start(); osc.stop(window.audioCtx.currentTime + dur);
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    canvas.addEventListener('pointerdown', handleInput);
    lastTimestamp = Date.now();
    requestAnimationFrame(loop);
}

function resize() {
    const scale = Math.min(window.innerWidth / GW, window.innerHeight / GH);
    canvas.width = GW * scale; canvas.height = GH * scale;
    ctx.scale(scale, scale);
}

function resetAndStart(isFullReset) {
    if(isFullReset) { totalScore = 0; movesLeft = 10; gameCount = 0; }
    else { gameCount++; }
    seatWind = WIND_ORDER[gameCount % 4];
    roundWind = WIND_ORDER[Math.floor((gameCount / 4) % 4)];
    timeLeft = 60; swapActionCount = 0; flowersWon = [];
    selectedHandIndex = -1; selectedPoolIndex = -1; drawGamePending = false;
    startOpeningSequence();
}

async function startOpeningSequence() {
    gameStatus = 'DEALING';
    deck = createDeck();
    hand = []; pool = []; flowersWon = [];
    const grabbingSteps = [4, 4, 4, 2]; 
    for(let stepCount of grabbingSteps) {
        for(let i = 0; i < stepCount; i++) {
            let t = deck.pop();
            t.x = 800; t.y = 1080 + Math.floor(hand.length / 7) * 145;
            hand.push(t);
            playTone(500 + (hand.length * 30), 0.08, 0.05);
            await delay(80); 
        }
        await delay(200); 
    }
    let hasFlower = true;
    while(hasFlower) {
        hasFlower = false;
        for(let i = 0; i < hand.length; i++) {
            if(hand[i].type === 'FLOWER') {
                playTone(1100, 0.2, 0.15);
                let flow = hand[i];
                flow.targetX = 60 + (flowersWon.length * 55); flow.targetY = 280;
                flowersWon.push(flow);
                let replacement = deck.pop(); 
                replacement.x = hand[i].x; replacement.y = hand[i].y - 150;
                hand[i] = replacement;
                hasFlower = true; await delay(300); break;
            }
        }
    }
    sortHand(); await delay(500); fillFullPool();
    gameStatus = 'PLAYING';
}

function fillFullPool() {
    pool = [];
    deck = deck.filter(t => t.type !== 'FLOWER');
    while(pool.length < 9 && deck.length > 0) {
        let t = deck.pop();
        t.x = GW/2; t.y = GH/2;
        let i = pool.length;
        t.targetX = 230 + (i % 3) * 130;
        t.targetY = 480 + Math.floor(i / 3) * 145;
        pool.push(t);
    }
    playTone(523, 0.1); 
    if (deck.length === 0) checkFinalPossibility();
}

async function checkFinalPossibility() {
    if (gameStatus !== 'PLAYING' || drawGamePending || deck.length > 0) return;
    const res = calculateTotalTai(hand, flowersWon);
    if (!res) {
        drawGamePending = true;
        await delay(1000); 
        triggerDrawGame();
    }
}

function triggerDrawGame() {
    const isEvil = (swapActionCount < 3);
    const penalty = isEvil ? 5 : 0;
    movesLeft = Math.max(0, movesLeft - penalty);
    gameStatus = 'WIN_ANIM';
    winInfo = { names: isEvil ? ["Ê¥óÁâåÊá≤ÁΩ∞ -5Ê≠•", "ÁÑ°ÁâåÂà§ÂÆö"] : ["ÊµÅÂ±Ä"], totalTai: 0, penalty: penalty, scale: 0, rewardMoves: 0 };
    playTone(isEvil ? 150 : 220, 0.6);
}

async function performSwap(hIdx, pIdx) {
    if (gameStatus !== 'PLAYING') return;
    movesLeft--; swapActionCount++;
    playTone(440, 0.05);
    const poolTile = { ...pool[pIdx] };
    hand[hIdx] = poolTile;
    pool.splice(pIdx, 1);
    selectedHandIndex = -1; selectedPoolIndex = -1;
    sortHand();
    await delay(300); 

    let results = calculateTotalTai(hand, flowersWon);
    if (results) {
        let sumTai = results.reduce((a, b) => a + b.tai, 0);
        totalScore += (sumTai * 1000);
        movesLeft += sumTai; 
        winInfo = { names: results.map(r => `${r.name} ${r.tai}Âè∞`), totalTai: sumTai, curScore: totalScore, scale: 0, rewardMoves: sumTai };
        gameStatus = 'WIN_ANIM'; playTone(880, 0.2);
    } else {
        if (movesLeft <= 0) gameStatus = 'FAIL';
        else if (deck.length === 0) checkFinalPossibility();
    }
}

function calculateTotalTai(h, flowers) {
    let taiList = [];
    const counts = {}; h.forEach(t => { const k = t.type + (t.val || t.txt); counts[k] = (counts[k] || 0) + 1; });

    // --- Ê†∏ÂøÉ‰øÆÊ≠£ÔºöÂ∫ïÂè∞Â¢ûÂä†ÁÇ∫ 3 Âè∞ ---
    taiList.push({ name: "Â∫ïÂè∞", tai: 3 });

    const seatIdx = WIND_ORDER.indexOf(seatWind); 
    let flowerIndices = flowers.map(f => TILES_DATA['FLOWER'].indexOf(f.txt));
    flowerIndices.forEach(idx => { if (idx === seatIdx || idx === seatIdx + 4) taiList.push({ name: `Ê≠£Ëä±(${FLOWER_NAMES[idx]})`, tai: 1 }); });
    if (flowerIndices.includes(0) && flowerIndices.includes(4)) taiList.push({ name: "Ê¢ÖÊò•Ëä±Â∞ç", tai: 1 });
    if (flowerIndices.includes(1) && flowerIndices.includes(5)) taiList.push({ name: "Ëò≠Â§èËä±Â∞ç", tai: 1 });
    if (flowerIndices.includes(2) && flowerIndices.includes(6)) taiList.push({ name: "Á´πÁßãËä±Â∞ç", tai: 1 });
    if (flowerIndices.includes(3) && flowerIndices.includes(7)) taiList.push({ name: "ËèäÂÜ¨Ëä±Â∞ç", tai: 1 });
    let set1 = [0,1,2,3].every(i => flowerIndices.includes(i));
    let set2 = [4,5,6,7].every(i => flowerIndices.includes(i));
    if (set1) taiList.push({ name: "ÂõõÂ≠£ÂÖ®", tai: 2 });
    if (set2) taiList.push({ name: "ÂõõÂêõÂ≠ê", tai: 2 });

    let pairs = 0; for (let k in counts) pairs += Math.floor(counts[k]/2);
    if (pairs === 7) return [{ name: "‰∏ÉÂ∞çÂ≠ê", tai: 4 }, ...taiList];

    let best = null;
    for (let key in counts) {
        if (counts[key] >= 2) {
            let tc = JSON.parse(JSON.stringify(counts)); tc[key] -= 2;
            let m = []; if (findMianzi(tc, m)) { best = { jiang: key, mianzi: m }; break; }
        }
    }
    if (!best) return null;

    const m = best.mianzi; const keCount = m.filter(x => x.type === 'ke').length;
    if (keCount === 4) taiList.push({ name: "Â∞çÂ∞çËÉ°", tai: 4 });
    let dragons = ['DRAGONüÄÑ', 'DRAGONüÄÖ', 'DRAGONüÄÜ'];
    let dKe = dragons.filter(d => m.some(x => x.type === 'ke' && x.tile === d)).length;
    if (dKe === 3) taiList.push({ name: "Â§ß‰∏âÂÖÉ", tai: 8 });
    else if (dKe === 2 && dragons.some(d => best.jiang === d)) taiList.push({ name: "Â∞è‰∏âÂÖÉ", tai: 4 });
    else dragons.forEach(d => { if(m.some(x => x.type === 'ke' && x.tile === d)) taiList.push({ name: `Â≠óÂè∞(${d[d.length-1]})`, tai: 1 }); });
    if (m.some(x => x.type === 'ke' && x.tile === 'WIND'+roundWind)) taiList.push({ name: "Â†¥È¢®Âè∞", tai: 1 });
    if (m.some(x => x.type === 'ke' && x.tile === 'WIND'+seatWind)) taiList.push({ name: "ÈñÄÈ¢®Âè∞", tai: 1 });

    const types = new Set(h.map(t => t.type));
    const suitC = Array.from(types).filter(t => ['MAN','TONG','TIAO'].includes(t)).length;
    if (suitC === 1 && !(types.has('WIND') || types.has('DRAGON'))) taiList.push({ name: "Ê∏Ö‰∏ÄËâ≤", tai: 8 });
    else if (suitC === 1 && (types.has('WIND') || types.has('DRAGON'))) taiList.push({ name: "Ê∑∑‰∏ÄËâ≤", tai: 4 });

    if (taiList.length === 1 || (taiList.length > 1 && taiList.every(t => t.name === "Â∫ïÂè∞" || t.name.includes("Ëä±")))) {
        taiList.push({ name: "Âπ≥ËÉ°", tai: 1 });
    }
    return taiList;
}

function findMianzi(counts, structures) {
    let first = null; const keys = Object.keys(counts).sort();
    for (let k of keys) if (counts[k] > 0) { first = k; break; }
    if (!first) return true;
    if (counts[first] >= 3) {
        counts[first] -= 3; structures.push({ type: 'ke', tile: first });
        if (findMianzi(counts, structures)) return true;
        structures.pop(); counts[first] += 3;
    }
    if (first.match(/MAN|TONG|TIAO/)) {
        let type = first.match(/MAN|TONG|TIAO/)[0], val = parseInt(first.replace(type, ''));
        let k2 = type + (val+1), k3 = type + (val+2);
        if (val <= 7 && counts[k2] > 0 && counts[k3] > 0) {
            counts[first]--; counts[k2]--; counts[k3]--; structures.push({ type: 'shun', tile: first });
            if (findMianzi(counts, structures)) return true;
            structures.pop(); counts[first]++; counts[k2]++; counts[k3]++;
        }
    }
    return false;
}

function draw() {
    ctx.clearRect(0, 0, GW, GH);
    ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.fillRect(0, 0, GW, 220);
    ctx.font = "bold 40px Arial"; ctx.textAlign = "center"; ctx.fillStyle = "#fff";
    ctx.fillText(`${roundWind}È¢®Âúà / ÈñÄÈ¢®${seatWind}`, 360, 60);
    ctx.fillStyle = movesLeft <= 3 ? "#f44" : "#0fc"; ctx.fillText(`Ê≠•Êï∏: ${movesLeft}`, 180, 130);
    ctx.fillStyle = "#fc0"; ctx.fillText(`ÊôÇÈñì: ${Math.ceil(timeLeft)}s`, 540, 130);
    ctx.fillText(`Á∏ΩÂàÜ: ${totalScore.toLocaleString()}`, 360, 190);
    ctx.font = "24px Arial"; ctx.fillStyle = "rgba(255,255,255,0.4)";
    let curSeat = WIND_ORDER.indexOf(seatWind);
    ctx.fillText(`ÁâåÂ∫´: ${deck.length} | Êú¨Â±ÄÊ≠£Ëä±: ${FLOWER_NAMES[curSeat]}, ${FLOWER_NAMES[curSeat+4]}`, 360, 440);
    flowersWon.forEach(f => drawTile(f.x, f.y, f.txt, '#f57c00', 50, 70, false, 28));
    pool.forEach((p, i) => drawTile(p.x, p.y, p.txt, getCol(p.type), 115, 160, i === selectedPoolIndex));

    if (gameStatus === 'PLAYING') {
        ctx.fillStyle = (deck.length > 0) ? "#e64a19" : "#ff4444";
        ctx.beginPath(); ctx.roundRect(200, 880, 320, 80, 15); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.font = "bold 35px Arial"; ctx.fillText(deck.length > 0 ? "Êõ¥ÊèõÁâåÊ±†" : "ÊâãÂãïÊµÅÂ±Ä", 360, 935);
        ctx.font = "24px Arial"; ctx.fillText(`Â∑≤ÊèõÁâå: ${swapActionCount}/3`, 360, 860);
    }
    ctx.fillStyle = "rgba(0,0,0,0.75)"; ctx.fillRect(0, 950, GW, 330);
    hand.forEach((t, i) => drawTile(t.x, t.y - (i===selectedHandIndex?45:0), t.txt, getCol(t.type), 85, 125, i===selectedHandIndex));
    
    if (gameStatus === 'WIN_ANIM') {
        ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0,0,GW,GH);
        ctx.save(); ctx.translate(360, 640); ctx.scale(winInfo.scale, winInfo.scale);
        ctx.fillStyle = "#fc0"; ctx.font = "bold 80px Arial"; ctx.fillText(winInfo.totalTai > 0 ? `${winInfo.totalTai} Âè∞!` : winInfo.names[0], 0, -180);
        ctx.fillStyle = "#0f0"; ctx.font = "bold 50px Arial"; if (winInfo.rewardMoves > 0) ctx.fillText(`+${winInfo.rewardMoves} Ê≠•ÁçéÂãµ`, 0, -100);
        ctx.fillStyle = "#fff"; ctx.font = "30px Arial"; winInfo.names.forEach((n, i) => { if(winInfo.totalTai > 0) ctx.fillText(n, 0, -20 + i * 40); });
        ctx.fillStyle = "#aaa"; ctx.fillText("ÈªûÊìäÁπºÁ∫å‰∏ã‰∏ÄÂ±Ä", 0, 320);
        ctx.restore();
        if(winInfo.scale < 1) winInfo.scale += 0.05;
    }
    if (gameStatus === 'START_SCREEN') drawOverlay("ÊãæÂÖ´ÈõÄÔºöÁÆóÁï™Á´∂ÊäÄ", "ÈñãÂßãÊåëÊà∞", "#fc0");
    if (gameStatus === 'FAIL') drawOverlay("ÁîüÂëΩËÄóÁõ°", "ÈáçÊñ∞ÈñãÂßã", "#f44");
}

function drawOverlay(title, btnText, btnCol) {
    ctx.fillStyle = "rgba(0,0,0,0.95)"; ctx.fillRect(0, 0, GW, GH);
    ctx.fillStyle = "#fff"; ctx.font = "bold 80px Arial"; ctx.textAlign = "center"; ctx.fillText(title, 360, 500);
    ctx.fillStyle = btnCol; ctx.beginPath(); ctx.roundRect(200, 600, 320, 120, 20); ctx.fill();
    ctx.fillStyle = "#000"; ctx.font = "bold 50px Arial"; ctx.fillText(btnText, 360, 675);
}

function handleInput(e) {
    const rect = canvas.getBoundingClientRect();
    const scale = canvas.width / GW;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const mx = (clientX - rect.left) / scale;
    const my = (clientY - rect.top) / scale;
    if (gameStatus === 'START_SCREEN' || gameStatus === 'FAIL') { resetAndStart(true); return; }
    if (gameStatus === 'WIN_ANIM' && winInfo.scale >= 1) { resetAndStart(false); return; }
    if (gameStatus !== 'PLAYING') return;
    if (mx > 200 && mx < 520 && my > 880 && my < 960) { if (deck.length > 0) fillFullPool(); else triggerDrawGame(); return; }
    if (my > 950) {
        hand.forEach((t, i) => {
            const x = 85 + (i % 7) * 92, y = 1080 + Math.floor(i / 7) * 145;
            if (Math.abs(mx - x) < 45 && Math.abs(my - y) < 65) {
                if (selectedPoolIndex !== -1) performSwap(i, selectedPoolIndex);
                else { selectedHandIndex = (selectedHandIndex === i) ? -1 : i; playTone(659, 0.05); }
            }
        });
    } else {
        pool.forEach((p, i) => {
            if (Math.abs(mx - p.x) < 60 && Math.abs(my - p.y) < 80) {
                if (selectedHandIndex !== -1) performSwap(selectedHandIndex, i);
                else { selectedPoolIndex = (selectedPoolIndex === i) ? -1 : i; playTone(523, 0.05); }
            }
        });
    }
}

function createDeck() {
    let d = [];
    ['MAN', 'TONG', 'TIAO'].forEach(type => { for (let i = 1; i <= 9; i++) { for (let n = 0; n < 4; n++) d.push({ type, val: i, txt: TILES_DATA[type][i-1] }); } });
    ['WIND', 'DRAGON'].forEach(type => { TILES_DATA[type].forEach(txt => { for (let n = 0; n < 4; n++) d.push({ type, txt: txt, val: null }); }); });
    TILES_DATA['FLOWER'].forEach(txt => { d.push({ type: 'FLOWER', txt: txt, val: null }); });
    for (let i = d.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [d[i], d[j]] = [d[j], d[i]]; }
    return d;
}

function drawTile(x, y, txt, color, w, h, isSel, fs) {
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 8); ctx.fill();
    ctx.strokeStyle = isSel ? "#fc0" : "#bbb"; ctx.lineWidth = isSel?5:2; ctx.stroke();
    ctx.fillStyle = color; ctx.font = `bold ${fs || w*0.75}px Arial`; ctx.textAlign="center"; ctx.textBaseline = "middle"; ctx.fillText(txt||'?', 0, 0);
    ctx.restore();
}

function sortHand() {
    const order = {'MAN':0, 'TONG':1, 'TIAO':2, 'WIND':3, 'DRAGON':4, 'FLOWER':5};
    hand.sort((a,b) => { if(a.type !== b.type) return order[a.type] - order[b.type]; return (a.val || a.txt).toString().localeCompare((b.val || b.txt).toString()); });
}

function getCol(t) { 
    if(t==='MAN') return '#d32f2f'; if(t==='TONG') return '#1976d2'; if(t==='TIAO') return '#2e7d32';
    return '#4a148c'; 
}

function update() {
    const now = Date.now(), dt = (now - lastTimestamp) / 1000;
    lastTimestamp = now;
    if (gameStatus === 'PLAYING') {
        timeLeft -= dt; if (timeLeft <= 0) gameStatus = 'FAIL';
        if (deck.length === 0 && !drawGamePending) checkFinalPossibility();
    }
    pool.forEach(p => { p.x += (p.targetX - p.x) * 0.15; p.y += (p.targetY - p.y) * 0.15; });
    hand.forEach((t, i) => {
        let tx = 85 + (i % 7) * 92, ty = 1080 + Math.floor(i / 7) * 145;
        t.x += (tx - t.x) * 0.18; t.y += (ty - t.y) * 0.18;
    });
    flowersWon.forEach(f => { if(f.targetX) { f.x += (f.targetX - f.x) * 0.1; f.y += (f.targetY - f.y) * 0.1; } });
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
</script>
</body>
</html>